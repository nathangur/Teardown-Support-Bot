{
  "version": "1.4.0",
  "functions": [
    {
      "name": "GetIntParam",
      "arguments": [
        {
          "name": "name",
          "desc": "Parameter name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "default",
          "desc": "Default parameter value",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Parameter value",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Retrieve blinkcount parameter, or set to 5 if omitted\nparameterBlinkCount = GetIntParam(\"blinkcount\", 5)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetFloatParam",
      "arguments": [
        {
          "name": "name",
          "desc": "Parameter name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "default",
          "desc": "Default parameter value",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Parameter value",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Retrieve speed parameter, or set to 10.0 if omitted\nparameterSpeed = GetFloatParam(\"speed\", 10.0)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetBoolParam",
      "arguments": [
        {
          "name": "name",
          "desc": "Parameter name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "default",
          "desc": "Default parameter value",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Parameter value",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "--Retrieve playsound parameter, or false if omitted\nparameterPlaySound = GetBoolParam(\"playsound\", false)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetStringParam",
      "arguments": [
        {
          "name": "name",
          "desc": "Parameter name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "default",
          "desc": "Default parameter value",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Parameter value",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "--Retrieve mode parameter, or \"idle\" if omitted\nparameterMode = GetSrtingParam(\"mode\", \"idle\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetVersion",
      "arguments": [],
      "returns": [
        {
          "name": "version",
          "desc": "Dot separated string of current version of the game",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "local v = GetVersion()\n--v is \"0.5.0\""
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "HasVersion",
      "arguments": [
        {
          "name": "version",
          "desc": "Reference version",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "match",
          "desc": "True if current version is at least provided one",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if HasVersion(\"0.6.0\") then\n\t--conditional code that only works on 0.6.0 or above\nelse\n\t--legacy code that works on earlier versions\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetTime",
      "arguments": [],
      "returns": [
        {
          "name": "time",
          "desc": "The time in seconds since level was started",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local t = GetTime()"
      ],
      "description": "Returns running time of this script. If called from update, this returns the\nsimulated time, otherwise it returns wall time.",
      "tables": {}
    },
    {
      "name": "GetTimeStep",
      "arguments": [],
      "returns": [
        {
          "name": "dt",
          "desc": "The timestep in seconds",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local dt = GetTimeStep()"
      ],
      "description": "Returns timestep of the last frame. If called from update, this returns the\nsimulation time step, which is always one 60th of a second (0.0166667). If\ncalled from tick or draw it returns the actual time since last frame.",
      "tables": {}
    },
    {
      "name": "InputLastPressedKey",
      "arguments": [],
      "returns": [
        {
          "name": "name",
          "desc": "Name of last pressed key, empty if no key is pressed",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "name = InputLastPressedKey()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "InputPressed",
      "arguments": [
        {
          "name": "input",
          "desc": "The input identifier",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "pressed",
          "desc": "True if input was pressed during last frame",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if InputPressed(\"interact\") then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "InputReleased",
      "arguments": [
        {
          "name": "input",
          "desc": "The input identifier",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "pressed",
          "desc": "True if input was released during last frame",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if InputReleased(\"interact\") then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "InputDown",
      "arguments": [
        {
          "name": "input",
          "desc": "The input identifier",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "pressed",
          "desc": "True if input is currently held down",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if InputDown(\"interact\") then\n...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "InputValue",
      "arguments": [
        {
          "name": "input",
          "desc": "The input identifier",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Depends on input type",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "scrollPos = scrollPos + InputValue(\"mousewheel\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetValue",
      "arguments": [
        {
          "name": "variable",
          "desc": "Name of number variable in the global context",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value",
          "desc": "The new value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "transition",
          "desc": "Transition type. See description.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "time",
          "desc": "Transition time (seconds)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "myValue = 0\nSetValue(\"myValue\", 1, \"linear\", 0.5)\n\nThis will change the value of myValue from 0 to 1 in a linear fasion over 0.5 seconds"
      ],
      "description": "Set value of a number variable in the global context with an optional\ntransition. If a transition is provided the value will animate from current\nvalue to the new value during the transition time. Transition can be one of the\nfollowing: ${table:Transition}",
      "tables": {
        "Transition": [
          [
            "linear",
            "Linear transition"
          ],
          [
            "cosine",
            "Slow at beginning and end"
          ],
          [
            "easein",
            "Slow at beginning"
          ],
          [
            "easeout",
            "Slow at end"
          ],
          [
            "bounce",
            "Bounce and overshoot new value"
          ]
        ]
      }
    },
    {
      "name": "PauseMenuButton",
      "arguments": [
        {
          "name": "title",
          "desc": "Text on button",
          "optional": false,
          "type": "string"
        },
        {
          "name": "primary",
          "desc": "Primary button",
          "optional": true,
          "type": "bool"
        }
      ],
      "returns": [
        {
          "name": "clicked",
          "desc": "True if clicked, false otherwise",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "function tick()\n\n    -- Primary button will be placed in the main pause menu\n\tif PauseMenuButton(\"Back to Hub\", true) then\n\t\tStartLevel(\"hub\", \"MOD/hub.xml\")\n\tend\n\t\n\t-- Button will be placed in the bottom bar of the pause menu\n\tif PauseMenuButton(\"MyMod Settings\") then\n\t\tvisible = true\n\tend\nend\n\nfunction draw()\n\tif visible then\n\t\tUiMakeInteractive()\n\t\t...\n\tend\nend"
      ],
      "description": "Calling this function will add a button on the bottom bar or in the main pause\nmenu (center of the screen) when the game is paused. A primary button will be\nplaced in the main pause menu if this function is called from a playable mod.\nThere can be only one primary button. Use this as a way to bring up mod settings\nor other user interfaces while the game is running. Call this function every\nframe from the tick function for as long as the pause menu button should still\nbe visible.",
      "tables": {}
    },
    {
      "name": "StartLevel",
      "arguments": [
        {
          "name": "mission",
          "desc": "An identifier of your choice",
          "optional": false,
          "type": "string"
        },
        {
          "name": "path",
          "desc": "Path to level XML file",
          "optional": false,
          "type": "string"
        },
        {
          "name": "layers",
          "desc": "Active layers. Default is no layers.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "passThrough",
          "desc": "If set, loading screen will have no text and music will keep playing",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "--Start level with no active layers\nStartLevel(\"level1\", \"MOD/level1.xml\")\n\n--Start level with two layers\nStartLevel(\"level1\", \"MOD/level1.xml\", \"vehicles targets\")"
      ],
      "description": "Start a level",
      "tables": {}
    },
    {
      "name": "SetPaused",
      "arguments": [
        {
          "name": "paused",
          "desc": "True if game should be paused",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "--Pause game and bring up pause menu on HUD\nSetPaused(true)"
      ],
      "description": "Set paused state of the game",
      "tables": {}
    },
    {
      "name": "Restart",
      "arguments": [],
      "returns": [],
      "examples": [
        "if shouldRestart then\nRestart()\nend"
      ],
      "description": "Restart level",
      "tables": {}
    },
    {
      "name": "Menu",
      "arguments": [],
      "returns": [],
      "examples": [
        "if shouldExitLevel then\nMenu()\nend"
      ],
      "description": "Go to main menu",
      "tables": {}
    },
    {
      "name": "ClearKey",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key to clear",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "--If the registry looks like this:\n--\tscore\n--\t\tlevels\n--\t\t\tlevel1 = 5\n--\t\t\tlevel2 = 4\n\nClearKey(\"score.levels\")\n\n--Afterwards, the registry will look like this:\n--\tscore"
      ],
      "description": "Remove registry node, including all child nodes.",
      "tables": {}
    },
    {
      "name": "ListKeys",
      "arguments": [
        {
          "name": "parent",
          "desc": "The parent registry key",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "children",
          "desc": "Indexed table of strings with child keys",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--If the registry looks like this:\n--\tscore\n--\t\tlevels\n--\t\t\tlevel1 = 5\n--\t\t\tlevel2 = 4\n\nlocal list = ListKeys(\"score.levels\")\nfor i=1, #list do\n\tprint(list[i])\nend\n\n--This will output:\n--level1\n--level2"
      ],
      "description": "List all child keys of a registry node.",
      "tables": {}
    },
    {
      "name": "HasKey",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "exists",
          "desc": "True if key exists",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local foo = HasKey(\"score.levels\")"
      ],
      "description": "Returns true if the registry contains a certain key",
      "tables": {}
    },
    {
      "name": "SetInt",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value",
          "desc": "Desired value",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "SetInt(\"score.levels.level1\", 4)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetInt",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Integer value of registry node or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local a = GetInt(\"score.levels.level1\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetFloat",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value",
          "desc": "Desired value",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "SetFloat(\"level.time\", 22.3)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetFloat",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Float value of registry node or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local time = GetFloat(\"level.time\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetBool",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value",
          "desc": "Desired value",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "SetBool(\"level.robots.enabled\", true)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetBool",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Boolean value of registry node or false if not found",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local isRobotsEnabled = GetBool(\"level.robots.enabled\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetString",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value",
          "desc": "Desired value",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "SetString(\"level.name\", \"foo\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetString",
      "arguments": [
        {
          "name": "key",
          "desc": "Registry key",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "String value of registry node or \"\" if not found",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "local name = GetString(\"level.name\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "Vec",
      "arguments": [
        {
          "name": "x",
          "desc": "X value",
          "optional": true,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y value",
          "optional": true,
          "type": "number"
        },
        {
          "name": "z",
          "desc": "Z value",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "vec",
          "desc": "New vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--These are equivalent\nlocal a1 = Vec()\nlocal a2 = {0, 0, 0}\n\n--These are equivalent\nlocal b1 = Vec(0, 1, 0)\nlocal b2 = {0, 1, 0}"
      ],
      "description": "Create new vector and optionally initializes it to the provided values. A Vec is\nequivalent to a regular lua table with three numbers.",
      "tables": {}
    },
    {
      "name": "VecCopy",
      "arguments": [
        {
          "name": "org",
          "desc": "A vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "new",
          "desc": "Copy of org vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Do this to assign a vector\nlocal right1 = Vec(1, 2, 3)\nlocal right2 = VecCopy(right1)\n\n--Never do this unless you REALLY know what you're doing\nlocal wrong1 = Vec(1, 2, 3)\nlocal wrong2 = wrong1"
      ],
      "description": "Vectors should never be assigned like regular numbers. Since they are\nimplemented with lua tables assignment means two references pointing to the same\ndata. Use this function instead.",
      "tables": {}
    },
    {
      "name": "VecLength",
      "arguments": [
        {
          "name": "vec",
          "desc": "A vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "length",
          "desc": "Length (magnitude) of the vector",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local v = Vec(1,1,0)\nlocal l = VecLength(v)\n\n--l now equals 1.41421356"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "VecNormalize",
      "arguments": [
        {
          "name": "vec",
          "desc": "A vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "norm",
          "desc": "A vector of length 1.0",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local v = Vec(0,3,0)\nlocal n = VecNormalize(v)\n\n--n now equals {0,1,0}"
      ],
      "description": "If the input vector is of zero length, the function returns {0,0,1}",
      "tables": {}
    },
    {
      "name": "VecScale",
      "arguments": [
        {
          "name": "vec",
          "desc": "A vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "scale",
          "desc": "A scale factor",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "norm",
          "desc": "A scaled version of input vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local v = Vec(1,2,3)\nlocal n = VecScale(v, 2)\n\n--n now equals {2,4,6}"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "VecAdd",
      "arguments": [
        {
          "name": "a",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "b",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "c",
          "desc": "New vector with sum of a and b",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local a = Vec(1,2,3)\nlocal b = Vec(3,0,0)\nlocal c = VecAdd(a, b)\n\n--c now equals {4,2,3}"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "VecSub",
      "arguments": [
        {
          "name": "a",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "b",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "c",
          "desc": "New vector representing a-b",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local a = Vec(1,2,3)\nlocal b = Vec(3,0,0)\nlocal c = VecSub(a, b)\n\n--c now equals {-2,2,3}"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "VecDot",
      "arguments": [
        {
          "name": "a",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "b",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "c",
          "desc": "Dot product of a and b",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local a = Vec(1,2,3)\nlocal b = Vec(3,1,0)\nlocal c = VecDot(a, b)\n\n--c now equals 5"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "VecCross",
      "arguments": [
        {
          "name": "a",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "b",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "c",
          "desc": "Cross product of a and b (also called vector product)",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local a = Vec(1,0,0)\nlocal b = Vec(0,1,0)\nlocal c = VecCross(a, b)\n\n--c now equals {0,0,1}"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "VecLerp",
      "arguments": [
        {
          "name": "a",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "b",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "t",
          "desc": "fraction (usually between 0.0 and 1.0)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "c",
          "desc": "Linearly interpolated vector between a and b, using t",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local a = Vec(2,0,0)\nlocal b = Vec(0,4,2)\nlocal t = 0.5\n\n--These two are equivalent\nlocal c1 = VecLerp(a, b, t)\nlcoal c2 = VecAdd(VecScale(a, 1-t), VecScale(b, t))\n\n--c1 and c2 now equals {1, 2, 1}"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "Quat",
      "arguments": [
        {
          "name": "x",
          "desc": "X value",
          "optional": true,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y value",
          "optional": true,
          "type": "number"
        },
        {
          "name": "z",
          "desc": "Z value",
          "optional": true,
          "type": "number"
        },
        {
          "name": "w",
          "desc": "W value",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "quat",
          "desc": "New quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--These are equivalent\nlocal a1 = Quat()\nlocal a2 = {0, 0, 0, 1}"
      ],
      "description": "Create new quaternion and optionally initializes it to the provided values. Do\nnot attempt to initialize a quaternion with raw values unless you know what you\nare doing. Use QuatEuler or QuatAxisAngle instead. If no arguments are given, a\nunit quaternion will be created: {0, 0, 0, 1}. A quaternion is equivalent to a\nregular lua table with four numbers.",
      "tables": {}
    },
    {
      "name": "QuatCopy",
      "arguments": [
        {
          "name": "org",
          "desc": "Quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "new",
          "desc": "Copy of org quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Do this to assign a quaternion\nlocal right1 = QuatEuler(0, 90, 0)\nlocal right2 = QuatCopy(right1)\n\n--Never do this unless you REALLY know what you're doing\nlocal wrong1 = QuatEuler(0, 90, 0)\nlocal wrong2 = wrong1"
      ],
      "description": "Quaternions should never be assigned like regular numbers. Since they are\nimplemented with lua tables assignment means two references pointing to the same\ndata. Use this function instead.",
      "tables": {}
    },
    {
      "name": "QuatAxisAngle",
      "arguments": [
        {
          "name": "axis",
          "desc": "Rotation axis, unit vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "angle",
          "desc": "Rotation angle in degrees",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "quat",
          "desc": "New quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Create quaternion representing rotation 30 degrees around Y axis\nlocal q = QuatAxisAngle(Vec(0,1,0), 30)"
      ],
      "description": "Create a quaternion representing a rotation around a specific axis",
      "tables": {}
    },
    {
      "name": "QuatEuler",
      "arguments": [
        {
          "name": "x",
          "desc": "Angle around X axis in degrees, sometimes also called roll or bank",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Angle around Y axis in degrees, sometimes also called yaw or heading",
          "optional": false,
          "type": "number"
        },
        {
          "name": "z",
          "desc": "Angle around Z axis in degrees, sometimes also called pitch or attitude",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "quat",
          "desc": "New quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Create quaternion representing rotation 30 degrees around Y axis and 25 degrees around Z axis\nlocal q = QuatEuler(0, 30, 25)"
      ],
      "description": "Create quaternion using euler angle notation. The order of applied rotations\nuses the \"NASA standard aeroplane\" model: <ol> <li>Rotation around Y axis (yaw\nor heading)</li> <li>Rotation around Z axis (pitch or attitude)</li>\n<li>Rotation around X axis (roll or bank)</li> </ol>",
      "tables": {}
    },
    {
      "name": "GetQuatEuler",
      "arguments": [
        {
          "name": "quat",
          "desc": "Quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "x",
          "desc": "Angle around X axis in degrees, sometimes also called roll or bank",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Angle around Y axis in degrees, sometimes also called yaw or heading",
          "optional": false,
          "type": "number"
        },
        {
          "name": "z",
          "desc": "Angle around Z axis in degrees, sometimes also called pitch or attitude",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Return euler angles from quaternion q\nrx, ry, rz = GetQuatEuler(q)"
      ],
      "description": "Return euler angles from quaternion. The order of rotations uses the \"NASA\nstandard aeroplane\" model: <ol> <li>Rotation around Y axis (yaw or heading)</li>\n<li>Rotation around Z axis (pitch or attitude)</li> <li>Rotation around X axis\n(roll or bank)</li> </ol>",
      "tables": {}
    },
    {
      "name": "QuatLookAt",
      "arguments": [
        {
          "name": "eye",
          "desc": "Vector representing the camera location",
          "optional": false,
          "type": "table"
        },
        {
          "name": "target",
          "desc": "Vector representing the point to look at",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "quat",
          "desc": "New quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local eye = Vec(0, 10, 0)\nlocal target = Vec(0, 1, 5)\nlocal rot = QuatLookAt(eye, target)\nSetCameraTransform(Transform(eye, rot))"
      ],
      "description": "Create a quaternion pointing the negative Z axis (forward) towards a specific\npoint, keeping the Y axis upwards. This is very useful for creating camera\ntransforms.",
      "tables": {}
    },
    {
      "name": "QuatSlerp",
      "arguments": [
        {
          "name": "a",
          "desc": "Quaternion",
          "optional": false,
          "type": "table"
        },
        {
          "name": "b",
          "desc": "Quaternion",
          "optional": false,
          "type": "table"
        },
        {
          "name": "t",
          "desc": "fraction (usually between 0.0 and 1.0)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "c",
          "desc": "New quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local a = QuatEuler(0, 10, 0)\nlocal b = QuatEuler(0, 0, 45)\n\n--Create quaternion half way between a and b\nlocal q = QuatSlerp(a, b, 0.5)"
      ],
      "description": "Spherical, linear interpolation between a and b, using t. This is very useful\nfor animating between two rotations.",
      "tables": {}
    },
    {
      "name": "QuatRotateQuat",
      "arguments": [
        {
          "name": "a",
          "desc": "Quaternion",
          "optional": false,
          "type": "table"
        },
        {
          "name": "b",
          "desc": "Quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "c",
          "desc": "New quaternion",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local a = QuatEuler(0, 10, 0)\nlocal b = QuatEuler(0, 0, 45)\nlocal q = QuatRotateQuat(a, b)\n\n--q now represents a rotation first 10 degrees around\n--the Y axis and then 45 degrees around the Z axis."
      ],
      "description": "Rotate one quaternion with another quaternion. This is mathematically equivalent\nto c = a * b using quaternion multiplication.",
      "tables": {}
    },
    {
      "name": "QuatRotateVec",
      "arguments": [
        {
          "name": "a",
          "desc": "Quaternion",
          "optional": false,
          "type": "table"
        },
        {
          "name": "vec",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "vec",
          "desc": "Rotated vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local q = QuatEuler(0, 10, 0)\nlocal v = Vec(1, 0, 0)\nlocal r = QuatRotateVec(q, v)\n\n--r is now vector a rotated 10 degrees around the Y axis"
      ],
      "description": "Rotate a vector by a quaternion",
      "tables": {}
    },
    {
      "name": "Transform",
      "arguments": [
        {
          "name": "pos",
          "desc": "Vector representing transform position",
          "optional": true,
          "type": "table"
        },
        {
          "name": "rot",
          "desc": "Quaternion representing transform rotation",
          "optional": true,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "New transform",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Create transform located at {0, 0, 0} with no rotation\nlocal t1 = Transform()\n\n--Create transform located at {10, 0, 0} with no rotation\nlocal t2 = Transform(Vec(10, 0,0))\n\n--Create transform located at {10, 0, 0}, rotated 45 degrees around Y axis\nlocal t2 = Transform(Vec(10, 0,0), QuatEuler(0, 45, 0))"
      ],
      "description": "A transform is a regular lua table with two entries: pos and rot, a vector and\nquaternion representing transform position and rotation.",
      "tables": {}
    },
    {
      "name": "TransformCopy",
      "arguments": [
        {
          "name": "org",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "new",
          "desc": "Copy of org transform",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Do this to assign a quaternion\nlocal right1 = Transform(Vec(1,0,0), QuatEuler(0, 90, 0))\nlocal right2 = TransformCopy(right1)\n\n--Never do this unless you REALLY know what you're doing\nlocal wrong1 = Transform(Vec(1,0,0), QuatEuler(0, 90, 0))\nlocal wrong2 = wrong1"
      ],
      "description": "Transforms should never be assigned like regular numbers. Since they are\nimplemented with lua tables assignment means two references pointing to the same\ndata. Use this function instead.",
      "tables": {}
    },
    {
      "name": "TransformToParentTransform",
      "arguments": [
        {
          "name": "parent",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "child",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "New transform",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local b = GetBodyTransform(body)\nlocal s = GetShapeLocalTransform(shape)\n\n--b represents the location of body in world space\n--s represents the location of shape in body space\n\nlocal w = TransformToParentTransform(b, s)\n\n--w now represents the location of shape in world space"
      ],
      "description": "Transform child transform out of the parent transform. This is the opposite of\nTransformToLocalTransform.",
      "tables": {}
    },
    {
      "name": "TransformToLocalTransform",
      "arguments": [
        {
          "name": "parent",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "child",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "New transform",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local b = GetBodyTransform(body)\nlocal w = GetShapeWorldTransform(shape)\n\n--b represents the location of body in world space\n--w represents the location of shape in world space\n\nlocal s = TransformToLocalTransform(b, w)\n\n--s now represents the location of shape in body space."
      ],
      "description": "Transform one transform into the local space of another transform. This is the\nopposite of TransformToParentTransform.",
      "tables": {}
    },
    {
      "name": "TransformToParentVec",
      "arguments": [
        {
          "name": "t",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "v",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "r",
          "desc": "Transformed vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetBodyTransform(body)\nlocal localUp = Vec(0, 1, 0)\nlocal up = TransformToParentVec(t, localUp)\n\n--up now represents the local body up direction in world space"
      ],
      "description": "Transfom vector v out of transform t only considering rotation.",
      "tables": {}
    },
    {
      "name": "TransformToLocalVec",
      "arguments": [
        {
          "name": "t",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "v",
          "desc": "Vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "r",
          "desc": "Transformed vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetBodyTransform(body)\nlocal worldUp = Vec(0, 1, 0)\nlocal up = TransformToLocalVec(t, worldUp)\n\n--up now represents the world up direction in local body space"
      ],
      "description": "Transfom vector v into transform t only considering rotation.",
      "tables": {}
    },
    {
      "name": "TransformToParentPoint",
      "arguments": [
        {
          "name": "t",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "p",
          "desc": "Vector representing position",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "r",
          "desc": "Transformed position",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetBodyTransform(body)\nlocal bodyPoint = Vec(0, 0, -1)\nlocal p = TransformToParentPoint(t, bodyPoint)\n\n--p now represents the local body point {0, 0, -1 } in world space"
      ],
      "description": "Transfom position p out of transform t.",
      "tables": {}
    },
    {
      "name": "TransformToLocalPoint",
      "arguments": [
        {
          "name": "t",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "p",
          "desc": "Vector representing position",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "r",
          "desc": "Transformed position",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetBodyTransform(body)\nlocal worldOrigo = Vec(0, 0, 0)\nlocal p = TransformToLocalPoint(t, worldOrigo)\n\n--p now represents the position of world origo in local body space"
      ],
      "description": "Transfom position p into transform t.",
      "tables": {}
    },
    {
      "name": "SetTag",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value",
          "desc": "Tag value",
          "optional": true,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "--Add \"special\" tag to an entity\nSetTag(handle, \"special\")\n\n--Add \"team\" tag to an entity and give it value \"red\"\nSetTag(handle, \"team\", \"red\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "RemoveTag",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "RemoveTag(handle, \"special\")"
      ],
      "description": "Remove tag from an entity. If the tag had a value it is removed too.",
      "tables": {}
    },
    {
      "name": "HasTag",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "exists",
          "desc": "Returns true if entity has tag",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "SetTag(handle, \"special\")\nlocal hasSpecial = HasTag(handle, \"special\") \n-- hasSpecial will be true"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetTagValue",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "Returns the tag value, if any. Empty string otherwise.",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "SetTag(handle, \"special\")\nvalue = GetTagValue(handle, \"special\")\n-- value will be \"\"\n\nSetTag(handle, \"special\", \"foo\")\nvalue = GetTagValue(handle, \"special\")\n-- value will be \"foo\""
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "ListTags",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "tags",
          "desc": "Indexed table of tags on entity",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--List all tags and their tag values for a particular entity\nlocal tags = ListTags(handle)\nfor i=1, #tags do\n\tDebugPrint(tags[i] .. \" \" .. GetTagValue(handle, tags[i]))\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetDescription",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "description",
          "desc": "The description string",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "local desc = GetDescription(body)"
      ],
      "description": "All entities can have an associated description. For bodies and shapes this can\nbe provided through the editor. This function retrieves that description.",
      "tables": {}
    },
    {
      "name": "SetDescription",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "description",
          "desc": "The description string",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "SetDescription(body, \"Target object\")"
      ],
      "description": "All entities can have an associated description. The description for bodies and\nshapes will show up on the HUD when looking at them.",
      "tables": {}
    },
    {
      "name": "Delete",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "Delete(body)\n--All shapes associated with body will also be removed"
      ],
      "description": "Remove an entity from the scene. All entities owned by this entity will also be\nremoved.",
      "tables": {}
    },
    {
      "name": "IsHandleValid",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "exists",
          "desc": "Returns true if the entity pointed to by handle still exists",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "valid = IsHandleValid(body)\n\n--valid is true if body still exists\n\nDelete(body)\nvalid = IsHandleValid(body)\n\n--valid will now be false"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetEntityType",
      "arguments": [
        {
          "name": "handle",
          "desc": "Entity handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "type",
          "desc": "Type name of the provided entity",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "local t = GetEntityType(e)\nif t == \"body\" then\n\t--e is a body handle\nend"
      ],
      "description": "Returns the type name of provided entity, for example \"body\", \"shape\", \"light\",\netc.",
      "tables": {}
    },
    {
      "name": "FindBody",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to first body with specified tag or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Search for a body tagged \"target\" in script scope\nlocal target = FindBody(\"target\")\n\n--Search for a body tagged \"escape\" in entire scene\nlocal escape = FindBody(\"escape\", true)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindBodies",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all bodies with specified tag",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Search for bodies tagged \"target\" in script scope\nlocal targets = FindBodies(\"target\")\nfor i=1, #targets do\n\tlocal target = targets[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetBodyTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "Transform of the body",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetBodyTransform(body)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetBodyTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "transform",
          "desc": "Desired transform",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "--Move a body 1 meter upwards\nlocal t = GetBodyTransform(body)\nt.pos = VecAdd(t.pos, Vec(0, 1, 0))\nSetBodyTransform(body, t)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetBodyMass",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "mass",
          "desc": "Body mass. Static bodies always return zero mass.",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local mass = GetBodyMass(body)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "IsBodyDynamic",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "dynamic",
          "desc": "Return true if body is dynamic",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local dynamic = IsBodyDynamic(body)"
      ],
      "description": "Check if body is dynamic. Note that something that was created static may become\ndynamic due to destruction.",
      "tables": {}
    },
    {
      "name": "SetBodyDynamic",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "dynamic",
          "desc": "True for dynamic. False for static.",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "SetBodyDynamic(body, false)"
      ],
      "description": "Change the dynamic state of a body. There is very limited use for this function.\nIn most situations you should leave it up to the engine to decide. Use with\ncaution.",
      "tables": {}
    },
    {
      "name": "SetBodyVelocity",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle (should be a dynamic body)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "velocity",
          "desc": "Vector with linear velocity",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "local vel = Vec(2,0,0)\nSetBodyVelocity(body, vel)"
      ],
      "description": "This can be used for animating bodies with preserved physical interaction, but\nin most cases you are better off with a motorized joint instead.",
      "tables": {}
    },
    {
      "name": "GetBodyVelocity",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle (should be a dynamic body)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "velocity",
          "desc": "Linear velocity as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local linVel = GetBodyVelocity(body)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetBodyVelocityAtPos",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle (should be a dynamic body)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "pos",
          "desc": "World space point as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "velocity",
          "desc": "Linear velocity on body at pos as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local vel = GetBodyVelocityAtPos(body, pos)"
      ],
      "description": "Return the velocity on a body taking both linear and angular velocity into\naccount.",
      "tables": {}
    },
    {
      "name": "SetBodyAngularVelocity",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle (should be a dynamic body)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "angVel",
          "desc": "Vector with angular velocity",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "local angVel = Vec(2,0,0)\nSetBodyAngularVelocity(body, angVel)"
      ],
      "description": "This can be used for animating bodies with preserved physical interaction, but\nin most cases you are better off with a motorized joint instead.",
      "tables": {}
    },
    {
      "name": "GetBodyAngularVelocity",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle (should be a dynamic body)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "angVel",
          "desc": "Angular velocity as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local angVel = GetBodyAngularVelocity(body)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "IsBodyActive",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "active",
          "desc": "Return true if body is active",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if IsBodyActive(body) then\n\t...\nend"
      ],
      "description": "Check if body is body is currently simulated. For performance reasons, bodies\nthat don't move are taken out of the simulation. This function can be used to\nquery the active state of a specific body. Only dynamic bodies can be active.",
      "tables": {}
    },
    {
      "name": "SetBodyActive",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "active",
          "desc": "Set to tru if body should be active (simulated)",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "--Wake up body\nSetBodyActive(body, true)\n\n--Put body to sleep\nSetBodyActive(body, false)"
      ],
      "description": "This function makes it possible to manually activate and deactivate bodies to\ninclude or exclude in simulation. The engine normally handles this\nautomatically, so use with care.",
      "tables": {}
    },
    {
      "name": "ApplyBodyImpulse",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle (should be a dynamic body)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "position",
          "desc": "World space position as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "impulse",
          "desc": "World space impulse as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "local pos = Vec(0,1,0)\nlocal imp = Vec(0,0,10)\nApplyBodyImpulse(body, pos, imp)"
      ],
      "description": "Apply impulse to dynamic body at position (give body a push).",
      "tables": {}
    },
    {
      "name": "GetBodyShapes",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table of shape handles",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local shapes = GetBodyShapes(body)\nfor i=1,#shapes do\n\tlocal shape = shapes[i]\nend"
      ],
      "description": "Return handles to all shapes owned by a body",
      "tables": {}
    },
    {
      "name": "GetBodyVehicle",
      "arguments": [
        {
          "name": "body",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Get parent vehicle for body, or zero if not part of vehicle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local vehicle = GetBodyVehicle(body)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetBodyBounds",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "min",
          "desc": "Vector representing the AABB lower bound",
          "optional": false,
          "type": "table"
        },
        {
          "name": "max",
          "desc": "Vector representing the AABB upper bound",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local min, max = GetBodyBounds(body)\nlocal boundsSize = VecSub(max, min)\nlocal center = VecLerp(min, max, 0.5)"
      ],
      "description": "Return the world space, axis-aligned bounding box for a body.",
      "tables": {}
    },
    {
      "name": "GetBodyCenterOfMass",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "point",
          "desc": "Vector representing local center of mass in body space",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Visualize center of mass on for body\nlocal com = GetBodyCenterOfMass(body)\nlocal worldPoint = TransformToParentPoint(GetBodyTransform(body), com)\nDebugCross(worldPoint)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "IsBodyVisible",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "maxDist",
          "desc": "Maximum visible distance",
          "optional": false,
          "type": "number"
        },
        {
          "name": "rejectTransparent",
          "desc": "See through transparent materials. Default false.",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "visible",
          "desc": "Return true if body is visible",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if IsBodyVisible(body, 25) then\n\t--Body is within 25 meters visible to the camera\nend"
      ],
      "description": "This will check if a body is currently visible in the camera frustum and not\noccluded by other objects.",
      "tables": {}
    },
    {
      "name": "IsBodyBroken",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "broken",
          "desc": "Return true if body is broken",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local broken = IsBodyBroken(body)"
      ],
      "description": "Determine if any shape of a body has been broken.",
      "tables": {}
    },
    {
      "name": "IsBodyJointedToStatic",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "result",
          "desc": "Return true if body is in any way connected to a static body",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local connectedToStatic = IsBodyJointedToStatic(body)"
      ],
      "description": "Determine if a body is in any way connected to a static object, either by being\nstatic itself or be being directly or indirectly jointed to something static.",
      "tables": {}
    },
    {
      "name": "DrawBodyOutline",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "r",
          "desc": "Red",
          "optional": true,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green",
          "optional": true,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue",
          "optional": true,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Draw white outline at 50% transparency\nDrawBodyOutline(body, 0.5)\n\n--Draw green outline, fully opaque\nDrawBodyOutline(body, 0, 1, 0, 1)"
      ],
      "description": "Render next frame with an outline around specified body. If no color is given, a\nwhite outline will be drawn.",
      "tables": {}
    },
    {
      "name": "DrawBodyHighlight",
      "arguments": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "amount",
          "desc": "Amount",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "DrawBodyHighlight(body, 0.5)"
      ],
      "description": "Flash the appearance of a body when rendering this frame. This is used for\nvaluables in the game.",
      "tables": {}
    },
    {
      "name": "GetBodyClosestPoint",
      "arguments": [
        {
          "name": "body",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "origin",
          "desc": "World space point",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "hit",
          "desc": "True if a point was found",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "point",
          "desc": "World space closest point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "normal",
          "desc": "World space normal at closest point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "shape",
          "desc": "Handle to closest shape",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local hit, p, n, s = GetBodyClosestPoint(body, Vec(0, 5, 0))\nif hit then\n\t--Point p of shape s is closest\nend"
      ],
      "description": "This will return the closest point of a specific body",
      "tables": {}
    },
    {
      "name": "ConstrainVelocity",
      "arguments": [
        {
          "name": "bodyA",
          "desc": "First body handle (zero for static)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "bodyB",
          "desc": "Second body handle (zero for static)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "point",
          "desc": "World space point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "dir",
          "desc": "World space direction",
          "optional": false,
          "type": "table"
        },
        {
          "name": "relVel",
          "desc": "Desired relative velocity along the provided direction",
          "optional": false,
          "type": "number"
        },
        {
          "name": "min",
          "desc": "Minimum impulse (default: -infinity)",
          "optional": true,
          "type": "number"
        },
        {
          "name": "max",
          "desc": "Maximum impulse (default: infinity)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Constrain the velocity between bodies A and B so that the relative velocity \n--along the X axis at point (0, 5, 0) is always 3 m/s\nConstrainVelocity(a, b, Vec(0, 5, 0), Vec(1, 0, 0), 3)"
      ],
      "description": "This will tell the physics solver to constrain the velocity between two bodies.\nThe physics solver will try to reach the desired goal, while not applying an\nimpulse bigger than the min and max values. This function should only be used\nfrom the update callback.",
      "tables": {}
    },
    {
      "name": "ConstrainAngularVelocity",
      "arguments": [
        {
          "name": "bodyA",
          "desc": "First body handle (zero for static)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "bodyB",
          "desc": "Second body handle (zero for static)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "dir",
          "desc": "World space direction",
          "optional": false,
          "type": "table"
        },
        {
          "name": "relAngVel",
          "desc": "Desired relative angular velocity along the provided direction",
          "optional": false,
          "type": "number"
        },
        {
          "name": "min",
          "desc": "Minimum angular impulse (default: -infinity)",
          "optional": true,
          "type": "number"
        },
        {
          "name": "max",
          "desc": "Maximum angular impulse (default: infinity)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Constrain the angular velocity between bodies A and B so that the relative angular velocity\n--along the Y axis is always 3 rad/s\nConstrainAngularVelocity(a, b, Vec(1, 0, 0), 3)"
      ],
      "description": "This will tell the physics solver to constrain the angular velocity between two\nbodies. The physics solver will try to reach the desired goal, while not\napplying an angular impulse bigger than the min and max values. This function\nshould only be used from the update callback.",
      "tables": {}
    },
    {
      "name": "ConstrainPosition",
      "arguments": [
        {
          "name": "bodyA",
          "desc": "First body handle (zero for static)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "bodyB",
          "desc": "Second body handle (zero for static)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "pointA",
          "desc": "World space point for first body",
          "optional": false,
          "type": "table"
        },
        {
          "name": "pointB",
          "desc": "World space point for second body",
          "optional": false,
          "type": "table"
        },
        {
          "name": "maxVel",
          "desc": "Maximum relative velocity (default: infinite)",
          "optional": true,
          "type": "number"
        },
        {
          "name": "maxImpulse",
          "desc": "Maximum impulse (default: infinite)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Constrain the origo of body a to an animated point in the world\nlocal worldPos = Vec(0, 3+math.sin(GetTime()), 0)\nConstrainPosition(a, 0, GetBodyTransform(a).pos, worldPos)\n\n--Constrain the origo of body a to the origo of body b (like a ball joint)\nConstrainPosition(a, b, GetBodyTransform(a).pos, GetBodyTransform(b).pos)"
      ],
      "description": "This is a helper function that uses ConstrainVelocity to constrain a point on\none body to a point on another body while not affecting the bodies more than the\nprovided maximum relative velocity and maximum impulse. In other words:\nphysically push on the bodies so that pointA and pointB are aligned in world\nspace. This is useful for physically animating objects. This function should\nonly be used from the update callback.",
      "tables": {}
    },
    {
      "name": "ConstrainOrientation",
      "arguments": [
        {
          "name": "bodyA",
          "desc": "First body handle (zero for static)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "bodyB",
          "desc": "Second body handle (zero for static)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "quatA",
          "desc": "World space orientation for first body",
          "optional": false,
          "type": "table"
        },
        {
          "name": "quatB",
          "desc": "World space orientation for second body",
          "optional": false,
          "type": "table"
        },
        {
          "name": "maxAngVel",
          "desc": "Maximum relative angular velocity (default: infinite)",
          "optional": true,
          "type": "number"
        },
        {
          "name": "maxAngImpulse",
          "desc": "Maximum angular impulse (default: infinite)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Constrain the orietation of body a to an upright orientation in the world\nConstrainOrientation(a, 0, GetBodyTransform(a).rot, Quat())\n\n--Constrain the orientation of body a to the orientation of body b\nConstrainOrientation(a, b, GetBodyTransform(a).rot, GetBodyTransform(b).rot)"
      ],
      "description": "This is the angular counterpart to ConstrainPosition, a helper function that\nuses ConstrainAngularVelocity to constrain the orientation of one body to the\norientation on another body while not affecting the bodies more than the\nprovided maximum relative angular velocity and maximum angular impulse. In other\nwords: physically rotate the bodies so that quatA and quatB are aligned in world\nspace. This is useful for physically animating objects. This function should\nonly be used from the update callback.",
      "tables": {}
    },
    {
      "name": "GetWorldBody",
      "arguments": [],
      "returns": [
        {
          "name": "body",
          "desc": "Handle to the static world body",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local w = GetWorldBody()"
      ],
      "description": "Every scene in Teardown has an implicit static world body that contains all\nshapes that are not explicitly assigned a body in the editor.",
      "tables": {}
    },
    {
      "name": "FindShape",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to first shape with specified tag or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Search for a shape tagged \"mybox\" in script scope\nlocal target = FindShape(\"mybox\")\n\n--Search for a shape tagged \"laserturret\" in entire scene\nlocal escape = FindShape(\"laserturret\", true)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindShapes",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all shapes with specified tag",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Search for shapes tagged \"alarmbox\" in script scope\nlocal shapes = FindShapes(\"alarmbox\")\nfor i=1, #shapes do\n\tlocal shape = shapes[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetShapeLocalTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "Return shape transform in body space",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Shape transform in body local space\nlocal shapeTransform = GetShapeLocalTransform(shape)\n\n--Body transform in world space\nlocal bodyTransform = GetBodyTransform(GetShapeBody(shape))\n\n--Shape transform in world space\nlocal worldTranform = TransformToParentTransform(bodyTransform, shapeTransform)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetShapeLocalTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "transform",
          "desc": "Shape transform in body space",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "local transform = Transform(Vec(0, 1, 0), QuatEuler(0, 90, 0))\nSetShapeLocalTransform(shape, transform)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetShapeWorldTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "Return shape transform in world space",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local worldTransform = GetShapeWorldTransform(shape)\n\n--This is equivalent to\nlocal shapeTransform = GetShapeLocalTransform(shape)\nlocal bodyTransform = GetBodyTransform(GetShapeBody(shape))\nworldTranform = TransformToParentTransform(bodyTransform, shapeTransform)"
      ],
      "description": "This is a convenience function, transforming the shape out of body space",
      "tables": {}
    },
    {
      "name": "GetShapeBody",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local body = GetShapeBody(shape)"
      ],
      "description": "Get handle to the body this shape is owned by. A shape is always owned by a\nbody, but can be transfered to a new body during destruction.",
      "tables": {}
    },
    {
      "name": "GetShapeJoints",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with joints connected to shape",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local hinges = GetShapeJoints(door)\nfor i=1, #hinges do\n\tlocal joint = hinges[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetShapeLights",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table of lights owned by shape",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local lights = GetShapeLights(shape)\nfor i=1, #lights do\n\tlocal light = lights[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetShapeBounds",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "min",
          "desc": "Vector representing the AABB lower bound",
          "optional": false,
          "type": "table"
        },
        {
          "name": "max",
          "desc": "Vector representing the AABB upper bound",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local min, max = GetShapeBounds(shape)\nlocal boundsSize = VecSub(max, min)\nlocal center = VecLerp(min, max, 0.5)"
      ],
      "description": "Return the world space, axis-aligned bounding box for a shape.",
      "tables": {}
    },
    {
      "name": "SetShapeEmissiveScale",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "scale",
          "desc": "Scale factor for emissiveness",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Pulsate emissiveness and light intensity for shape\nlocal scale = math.sin(GetTime())*0.5 + 0.5\nSetShapeEmissiveScale(shape, scale)"
      ],
      "description": "Scale emissiveness for shape. If the shape has light sources attached, their\nintensity will be scaled by the same amount.",
      "tables": {}
    },
    {
      "name": "GetShapeMaterialAtPosition",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "pos",
          "desc": "Position in world space",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "type",
          "desc": "Material type",
          "optional": false,
          "type": "string"
        },
        {
          "name": "r",
          "desc": "Red",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue",
          "optional": false,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha",
          "optional": false,
          "type": "number"
        },
        {
          "name": "entry",
          "desc": "Palette entry for voxel (zero if empty)",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local hit, dist, normal, shape = QueryRaycast(pos, dir, 10)\nif hit then\n\tlocal hitPoint = VecAdd(pos, VecScale(dir, dist))\n\tlocal mat = GetShapeMaterialAtPosition(shape, hitPoint)\n\tDebugPrint(\"Raycast hit voxel made out of \" .. mat)\nend"
      ],
      "description": "Return material properties for a particular voxel",
      "tables": {}
    },
    {
      "name": "GetShapeMaterialAtIndex",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "x",
          "desc": "X integer coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y integer coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "z",
          "desc": "Z integer coordinate",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "type",
          "desc": "Material type",
          "optional": false,
          "type": "string"
        },
        {
          "name": "r",
          "desc": "Red",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue",
          "optional": false,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha",
          "optional": false,
          "type": "number"
        },
        {
          "name": "entry",
          "desc": "Palette entry for voxel (zero if empty)",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local mat = GetShapeMaterialAtIndex(shape, 0, 0, 0)\nDebugPrint(\"The voxel closest to origo is of material: \" .. mat)"
      ],
      "description": "Return material properties for a particular voxel in the voxel grid indexed by\ninteger values. The first index is zero (not one, as opposed to a lot of lua\nrelated things)",
      "tables": {}
    },
    {
      "name": "GetShapeSize",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "xsize",
          "desc": "Size in voxels along x axis",
          "optional": false,
          "type": "number"
        },
        {
          "name": "ysize",
          "desc": "Size in voxels along y axis",
          "optional": false,
          "type": "number"
        },
        {
          "name": "zsize",
          "desc": "Size in voxels along z axis",
          "optional": false,
          "type": "number"
        },
        {
          "name": "scale",
          "desc": "The size of one voxel in meters (with default scale it is 0.1)",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local x, y, z = GetShapeSize(shape)"
      ],
      "description": "Return the size of a shape in voxels",
      "tables": {}
    },
    {
      "name": "GetShapeVoxelCount",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "count",
          "desc": "Number of voxels in shape",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local voxelCount = GetShapeVoxelCount(shape)"
      ],
      "description": "Return the number of voxels in a shape, not including empty space",
      "tables": {}
    },
    {
      "name": "IsShapeVisible",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "maxDist",
          "desc": "Maximum visible distance",
          "optional": false,
          "type": "number"
        },
        {
          "name": "rejectTransparent",
          "desc": "See through transparent materials. Default false.",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "visible",
          "desc": "Return true if shape is visible",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if IsShapeVisible(shape, 25) then\n\t--Shape is within 25 meters visible to the camera\nend"
      ],
      "description": "This will check if a shape is currently visible in the camera frustum and not\noccluded by other objects.",
      "tables": {}
    },
    {
      "name": "IsShapeBroken",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "broken",
          "desc": "Return true if shape is broken",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local broken = IsShapeBroken(shape)"
      ],
      "description": "Determine if shape has been broken. Note that a shape can be transfered to\nanother body during destruction, but might still not be considered broken if all\nvoxels are intact.",
      "tables": {}
    },
    {
      "name": "DrawShapeOutline",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "r",
          "desc": "Red",
          "optional": true,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green",
          "optional": true,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue",
          "optional": true,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Draw white outline at 50% transparency\nDrawShapeOutline(shape, 0.5)\n\n--Draw green outline, fully opaque\nDrawShapeOutline(shape, 0, 1, 0, 1)"
      ],
      "description": "Render next frame with an outline around specified shape. If no color is given,\na white outline will be drawn.",
      "tables": {}
    },
    {
      "name": "DrawShapeHighlight",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "amount",
          "desc": "Amount",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "DrawShapeHighlight(shape, 0.5)"
      ],
      "description": "Flash the appearance of a shape when rendering this frame.",
      "tables": {}
    },
    {
      "name": "SetShapeCollisionFilter",
      "arguments": [
        {
          "name": "handle",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "layer",
          "desc": "Layer bits (0-255)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "mask",
          "desc": "Mask bits (0-255)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--This will put shapes a and b in layer 2 and disable collisions with\n--object shapes in layers 2, preventing any collisions between the two.\nSetShapeCollisionFilter(a, 2, 255-2)\nSetShapeCollisionFilter(b, 2, 255-2)\n\n--This will put shapes c and d in layer 4 and allow collisions with other\n--shapes in layer 4, but ignore all other collisions with the rest of the world.\nSetShapeCollisionFilter(c, 4, 4)\nSetShapeCollisionFilter(d, 4, 4)"
      ],
      "description": "This is used to filter out collisions with other shapes. Each shape can be given\na layer bitmask (8 bits, 0-255) along with a mask (also 8 bits). The layer of\none object must be in the mask of the other object and vice versa for the\ncollision to be valid. The default layer for all objects is 1 and the default\nmask is 255 (collide with all layers).",
      "tables": {}
    },
    {
      "name": "CreateShape",
      "arguments": [
        {
          "name": "body",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "transform",
          "desc": "Shape transform in body space",
          "optional": false,
          "type": "table"
        },
        {
          "name": "refShape",
          "desc": "Handle to reference shape or path to vox file",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "newShape",
          "desc": "Handle of new shape",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        null
      ],
      "description": "Create new, empty shape on existing body using the palette of a reference shape.\nThe reference shape can be any existingf shape in the scene or an external vox\nfile. The size of the new shape will be 1x1x1.",
      "tables": {}
    },
    {
      "name": "ClearShape",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        null
      ],
      "description": "Fill a voxel shape with zeroes, thus removing all voxels.",
      "tables": {}
    },
    {
      "name": "ResizeShape",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "xmi",
          "desc": "Lower X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "ymi",
          "desc": "Lower Y coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "zmi",
          "desc": "Lower Z coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "xma",
          "desc": "Upper X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "yma",
          "desc": "Upper Y coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "zma",
          "desc": "Upper Z coordinate",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "offset",
          "desc": "Offset vector in shape local space",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        null
      ],
      "description": "Resize an existing shape. The new coordinates are expressed in the existing\nshape coordinate frame, so you can provide negative values. The existing content\nis preserved, but may be cropped if needed. The local shape transform will be\nmoved automatically with an offset vector to preserve the original content in\nbody space. This offset vector is returned in shape local space.",
      "tables": {}
    },
    {
      "name": "SetShapeBody",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "body",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "transform",
          "desc": "New local shape transform. Default is existing local transform.",
          "optional": true,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        null
      ],
      "description": "Move existing shape to a new body, optionally providing a new local transform.",
      "tables": {}
    },
    {
      "name": "CopyShapeContent",
      "arguments": [
        {
          "name": "src",
          "desc": "Source shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "dst",
          "desc": "Destination shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        null
      ],
      "description": "Copy voxel content from source shape to destination shape. If destination shape\nhas a different size, it will be resized to match the source shape.",
      "tables": {}
    },
    {
      "name": "CopyShapePalette",
      "arguments": [
        {
          "name": "src",
          "desc": "Source shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "dst",
          "desc": "Destination shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        null
      ],
      "description": "Copy the palette from source shape to destination shape.",
      "tables": {}
    },
    {
      "name": "GetShapePalette",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "entries",
          "desc": "Palette material entries",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        null
      ],
      "description": "Return list of material entries, each entry is a material index that can be\nprovided to GetShapeMaterial or used as brush for populating a shape.",
      "tables": {}
    },
    {
      "name": "GetShapeMaterial",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "entry",
          "desc": "Material entry",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "type",
          "desc": "Type",
          "optional": false,
          "type": "string"
        },
        {
          "name": "red",
          "desc": "Red value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "green",
          "desc": "Green value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "blue",
          "desc": "Blue value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "alpha",
          "desc": "Alpha value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "reflectivity",
          "desc": "Range 0 to 1",
          "optional": false,
          "type": "number"
        },
        {
          "name": "shininess",
          "desc": "Range 0 to 1",
          "optional": false,
          "type": "number"
        },
        {
          "name": "metallic",
          "desc": "Range 0 to 1",
          "optional": false,
          "type": "number"
        },
        {
          "name": "emissive",
          "desc": "Range 0 to 32",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        null
      ],
      "description": "Return material properties for specific matirial entry.",
      "tables": {}
    },
    {
      "name": "SetBrush",
      "arguments": [
        {
          "name": "type",
          "desc": "One of \"sphere\", \"cube\" or \"noise\"",
          "optional": false,
          "type": "string"
        },
        {
          "name": "size",
          "desc": "Size of brush in voxels (must be in range 1 to 16)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "index",
          "desc": "Material index or path to brush vox file",
          "optional": false,
          "type": "or"
        },
        {
          "name": "object",
          "desc": "Optional object in brush vox file if brush vox file is used",
          "optional": true,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        null
      ],
      "description": "Set material index to be used for following calls to DrawShapeLine and\nDrawShapeBox and ExtrudeShape. An optional brush vox file and subobject can be\nused and provided instead of material index, in which case the content of the\nbrush will be used and repeated. Use material index zero to remove of voxels.",
      "tables": {}
    },
    {
      "name": "DrawShapeLine",
      "arguments": [
        {
          "name": "shape",
          "desc": "Handle to shape",
          "optional": false,
          "type": "number"
        },
        {
          "name": "x0",
          "desc": "Start X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y0",
          "desc": "Start Y coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "z0",
          "desc": "Start Z coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "x1",
          "desc": "End X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y1",
          "desc": "End Y coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "z1",
          "desc": "End Z coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "paint",
          "desc": "Paint mode. Default is false.",
          "optional": true,
          "type": "bool"
        },
        {
          "name": "noOverwrite",
          "desc": "Only fill in voxels if space isn't already occupied. Default is false.",
          "optional": true,
          "type": "bool"
        }
      ],
      "returns": [],
      "examples": [
        null
      ],
      "description": "Draw voxelized line between (x0,y0,z0) and (x1,y1,z1) into shape using the\nmaterial set up with SetBrush. Paint mode will only change material of existing\nvoxels (where the current material index is non-zero). noOverwrite mode will\nonly fill in voxels if the space isn't already accupied by another shape in the\nscene.",
      "tables": {}
    },
    {
      "name": "DrawShapeBox",
      "arguments": [
        {
          "name": "shape",
          "desc": "Handle to shape",
          "optional": false,
          "type": "number"
        },
        {
          "name": "x0",
          "desc": "Start X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y0",
          "desc": "Start Y coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "z0",
          "desc": "Start Z coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "x1",
          "desc": "End X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y1",
          "desc": "End Y coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "z1",
          "desc": "End Z coordinate",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        null
      ],
      "description": "Draw box between (x0,y0,z0) and (x1,y1,z1) into shape using the material set up\nwith SetBrush.",
      "tables": {}
    },
    {
      "name": "ExtrudeShape",
      "arguments": [
        {
          "name": "shape",
          "desc": "Handle to shape",
          "optional": false,
          "type": "number"
        },
        {
          "name": "x",
          "desc": "X coordinate to extrude",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y coordinate to extrude",
          "optional": false,
          "type": "number"
        },
        {
          "name": "z",
          "desc": "Z coordinate to extrude",
          "optional": false,
          "type": "number"
        },
        {
          "name": "dx",
          "desc": "X component of extrude direction, should be -1, 0 or 1",
          "optional": false,
          "type": "number"
        },
        {
          "name": "dy",
          "desc": "Y component of extrude direction, should be -1, 0 or 1",
          "optional": false,
          "type": "number"
        },
        {
          "name": "dz",
          "desc": "Z component of extrude direction, should be -1, 0 or 1",
          "optional": false,
          "type": "number"
        },
        {
          "name": "steps",
          "desc": "Length of extrusion in voxels",
          "optional": false,
          "type": "number"
        },
        {
          "name": "mode",
          "desc": "Extrusion mode, one of \"exact\", \"material\", \"geometry\". Default is \"exact\"",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        null
      ],
      "description": "Extrude region of shape. The extruded region will be filled in with the material\nset up with SetBrush. The mode parameter sepcifies how the region is determined.\nExact mode selects region of voxels that exactly match the input voxel at input\ncoordinate. Material mode selects region that has the same material type as the\ninput voxel. Geometry mode selects any connected voxel in the same plane as the\ninput voxel.",
      "tables": {}
    },
    {
      "name": "TrimShape",
      "arguments": [
        {
          "name": "shape",
          "desc": "Source handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "offset",
          "desc": "Offset vector in shape local space",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        null
      ],
      "description": "Trim away empty regions of shape, thus potentially making it smaller. If the\nsize of the shape changes, the shape will be automatically moved to preserve the\nshape content in body space. The offset vector for this translation is returned\nin shape local space.",
      "tables": {}
    },
    {
      "name": "SplitShape",
      "arguments": [
        {
          "name": "shape",
          "desc": "Source handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "removeResidual",
          "desc": "Remove residual shapes (default false)",
          "optional": false,
          "type": "bool"
        }
      ],
      "returns": [
        {
          "name": "newShapes",
          "desc": "List of shape handles created",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        null
      ],
      "description": "Split up a shape into multiple shapes based on connectivity. If the\nremoveResidual flag is used, small disconnected chunks will be removed during\nthis process to reduce the number of newly created shapes.",
      "tables": {}
    },
    {
      "name": "MergeShape",
      "arguments": [
        {
          "name": "shape",
          "desc": "Input shape",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "shape",
          "desc": "Shape handle after merge",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        null
      ],
      "description": "Try to merge shape with a nearby, matching shape. For a merge to happen, the\nshapes need to be aligned to the same rotation and touching. If the provided\nshape was merged into another shape, that shape may be resized to fit the merged\ncontent. If shape was merged, the handle to the other shape is returned,\notherwise the input handle is returned.",
      "tables": {}
    },
    {
      "name": "GetShapeClosestPoint",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "origin",
          "desc": "World space point",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "hit",
          "desc": "True if a point was found",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "point",
          "desc": "World space closest point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "normal",
          "desc": "World space normal at closest point",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local hit, p, n = GetShapeClosestPoint(s, Vec(0, 5, 0))\nif hit then\n\t--Point p of shape s is closest to (0,5,0)\nend"
      ],
      "description": "This will return the closest point of a specific shape",
      "tables": {}
    },
    {
      "name": "IsShapeTouching",
      "arguments": [
        {
          "name": "a",
          "desc": "Handle to first shape",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Handle to second shape",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "touching",
          "desc": "True is shapes a and b are touching each other",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local touch = IsShapeTouching(a, b)\nif hit then\n\t--Shapes are touching or overlapping\nend"
      ],
      "description": "This will check if two shapes has physical overlap",
      "tables": {}
    },
    {
      "name": "FindLocation",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to first location with specified tag or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local loc = FindLocation(\"start\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindLocations",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all locations with specified tag",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Search for locations tagged \"waypoint\" in script scope\nlocal locations = FindLocations(\"waypoint\")\nfor i=1, #locs do\n\tlocal locs = locations[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetLocationTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Location handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "Transform of the location",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetLocationTransform(loc)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindJoint",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to first joint with specified tag or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local joint = FindJoint(\"doorhinge\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindJoints",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all joints with specified tag",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Search for locations tagged \"doorhinge\" in script scope\nlocal hinges = FindJoints(\"doorhinge\")\nfor i=1, #hinges do\n\tlocal joint = hinges[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "IsJointBroken",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "broken",
          "desc": "True if joint is broken",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local broken = IsJointBroken(joint)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetJointType",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "type",
          "desc": "Joint type",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "if GetJointType(joint) == \"rope\" then\n\t--Joint is rope\nend"
      ],
      "description": "Joint type is one of the following: \"ball\", \"hinge\", \"prismatic\" or \"rope\". An\nempty string is returned if joint handle is invalid.",
      "tables": {}
    },
    {
      "name": "GetJointOtherShape",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "other",
          "desc": "Other shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--joint is connected to a and b\n\notherShape = GetJointOtherShape(joint, a)\n--otherShape is now b\n\notherShape = GetJointOtherShape(joint, b)\n--otherShape is now a"
      ],
      "description": "A joint is always connected to two shapes. Use this function if you know one\nshape and want to find the other one.",
      "tables": {}
    },
    {
      "name": "GetJointShapes",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "shapes",
          "desc": "Shape handles",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "-- Check to see if joint chain is still connected to vehicle main body\n-- If not then disable motors\n\nlocal mainBody = GetVehicleBody(vehicle)\nlocal shapes = GetJointShapes(joint)\n\nlocal connected = false\nfor i=1,#shapes do\n\n\tlocal body = GetShapeBody(shapes[i])\n\n\tif body == mainBody then\n\t\tconnected = true\n\tend\n\nend\n\nif connected then\n\tSetJointMotor(joint, 0.5)\nelse\n\tSetJointMotor(joint, 0.0)\nend"
      ],
      "description": "Get shapes connected to the joint.",
      "tables": {}
    },
    {
      "name": "SetJointMotor",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "velocity",
          "desc": "Desired velocity",
          "optional": false,
          "type": "number"
        },
        {
          "name": "strength",
          "desc": "Desired strength. Default is infinite. Zero to disable.",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Set motor speed to 0.5 radians per second\nSetJointMotor(hinge, 0.5)"
      ],
      "description": "Set joint motor target velocity. If joint is of type hinge, velocity is given in\nradians per second angular velocity. If joint type is prismatic joint velocity\nis given in meters per second. Calling this function will override and void any\nprevious call to SetJointMotorTarget.",
      "tables": {}
    },
    {
      "name": "SetJointMotorTarget",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "target",
          "desc": "Desired movement target",
          "optional": false,
          "type": "number"
        },
        {
          "name": "maxVel",
          "desc": "Maximum velocity to reach target. Default is infinite.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "strength",
          "desc": "Desired strength. Default is infinite. Zero to disable.",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Make joint reach a 45 degree angle, going at a maximum of 3 radians per second\nSetJointMotorTarget(hinge, 45, 3)"
      ],
      "description": "If a joint has a motor target, it will try to maintain its relative movement.\nThis is very useful for elevators or other animated, jointed mechanisms. If\njoint is of type hinge, target is an angle in degrees (-180 to 180) and velocity\nis given in radians per second. If joint type is prismatic, target is given in\nmeters and velocity is given in meters per second. Setting a motor target will\noverride any previous call to SetJointMotor.",
      "tables": {}
    },
    {
      "name": "GetJointLimits",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "min",
          "desc": "Minimum joint limit (angle or distance)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "max",
          "desc": "Maximum joint limit (angle or distance)",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local min, max = GetJointLimits(hinge)"
      ],
      "description": "Return joint limits for hinge or prismatic joint. Returns angle or distance\ndepending on joint type.",
      "tables": {}
    },
    {
      "name": "GetJointMovement",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "movement",
          "desc": "Current joint position or angle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local current = GetJointMovement(hinge)"
      ],
      "description": "Return the current position or angle or the joint, measured in same way as joint\nlimits.",
      "tables": {}
    },
    {
      "name": "GetJointedBodies",
      "arguments": [
        {
          "name": "body",
          "desc": "Body handle (must be dynamic)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "bodies",
          "desc": "Handles to all dynamic bodies in the jointed structure. The input handle will also be included.",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Draw outline for all bodies in jointed structure\nlocal all = GetJointedBodies(body)\nfor i=1,#all do\n\tDrawBodyOutline(all[i], 0.5)\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "DetachJointFromShape",
      "arguments": [
        {
          "name": "joint",
          "desc": "Joint handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "DetachJointFromShape(hinge, door)"
      ],
      "description": "Detach joint from shape. If joint is not connected to shape, nothing happens.",
      "tables": {}
    },
    {
      "name": "FindLight",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to first light with specified tag or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local light = FindLight(\"main\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindLights",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all lights with specified tag",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Search for lights tagged \"main\" in script scope\nlocal lights = FindLights(\"main\")\nfor i=1, #lights do\n\tlocal light = lights[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetLightEnabled",
      "arguments": [
        {
          "name": "handle",
          "desc": "Light handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "enabled",
          "desc": "Set to true if light should be enabled",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "SetLightEnabled(light, false)"
      ],
      "description": "If light is owned by a shape, the emissive scale of that shape will be set to\n0.0 when light is disabled and 1.0 when light is enabled.",
      "tables": {}
    },
    {
      "name": "SetLightColor",
      "arguments": [
        {
          "name": "handle",
          "desc": "Light handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "r",
          "desc": "Red value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue value",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Set light color to yellow\nSetLightColor(light, 1, 1, 0)"
      ],
      "description": "This will only set the color tint of the light. Use SetLightIntensity for\nbrightness. Setting the light color will not affect the emissive color of a\nparent shape.",
      "tables": {}
    },
    {
      "name": "SetLightIntensity",
      "arguments": [
        {
          "name": "handle",
          "desc": "Light handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "intensity",
          "desc": "Desired intensity of the light",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Pulsate light\nSetLightIntensity(light, math.sin(GetTime())*0.5 + 1.0)"
      ],
      "description": "If the shape is owned by a shape you most likely want to use\nSetShapeEmissiveScale instead, which will affect both the emissiveness of the\nshape and the brightness of the light at the same time.",
      "tables": {}
    },
    {
      "name": "GetLightTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Light handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "World space light transform",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local pos = GetLightTransform(light).pos"
      ],
      "description": "Lights that are owned by a dynamic shape are automatcially moved with that shape",
      "tables": {}
    },
    {
      "name": "GetLightShape",
      "arguments": [
        {
          "name": "handle",
          "desc": "Light handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Shape handle or zero if not attached to shape",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local shape = GetLightShape(light)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "IsLightActive",
      "arguments": [
        {
          "name": "handle",
          "desc": "Light handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "active",
          "desc": "True if light is currently emitting light",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if IsLightActive(light) then\n\t--Do something\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "IsPointAffectedByLight",
      "arguments": [
        {
          "name": "handle",
          "desc": "Light handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "point",
          "desc": "World space point as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "affected",
          "desc": "Return true if point is in light cone and range",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local point = Vec(0, 10, 0)\nlocal affected = IsPointAffectedByLight(light, point)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindTrigger",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to first trigger with specified tag or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local goal = FindTrigger(\"goal\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindTriggers",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all triggers with specified tag",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Find triggers tagged \"toxic\" in script scope\nlocal triggers = FindTriggers(\"toxic\")\nfor i=1, #triggers do\n\tlocal trigger = triggers[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetTriggerTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "Current trigger transform in world space",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetTriggerTransform(trigger)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetTriggerTransform",
      "arguments": [
        {
          "name": "handle",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "transform",
          "desc": "Desired trigger transform in world space",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "local t = Transform(Vec(0, 1, 0), QuatEuler(0, 90, 0))\nSetTriggerTransform(trigger, t)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetTriggerBounds",
      "arguments": [
        {
          "name": "handle",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "min",
          "desc": "Lower point of trigger bounds in world space",
          "optional": false,
          "type": "table"
        },
        {
          "name": "max",
          "desc": "Upper point of trigger bounds in world space",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local mi, ma = GetTriggerBounds(trigger)\nlocal list = QueryAabbShapes(mi, ma)"
      ],
      "description": "Return the lower and upper points in world space of the trigger axis aligned\nbounding box",
      "tables": {}
    },
    {
      "name": "IsBodyInTrigger",
      "arguments": [
        {
          "name": "trigger",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "body",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "inside",
          "desc": "True if body is in trigger volume",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if IsBodyInTrigger(trigger, body) then\n\t...\nend"
      ],
      "description": "This function will only check the center point of the body",
      "tables": {}
    },
    {
      "name": "IsVehicleInTrigger",
      "arguments": [
        {
          "name": "trigger",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "vehicle",
          "desc": "Vehicle handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "inside",
          "desc": "True if vehicle is in trigger volume",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if IsVehicleInTrigger(trigger, vehicle) then\n\t...\nend"
      ],
      "description": "This function will only check origo of vehicle",
      "tables": {}
    },
    {
      "name": "IsShapeInTrigger",
      "arguments": [
        {
          "name": "trigger",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "inside",
          "desc": "True if shape is in trigger volume",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if IsShapeInTrigger(trigger, shape) then\n\t...\nend"
      ],
      "description": "This function will only check the center point of the shape",
      "tables": {}
    },
    {
      "name": "IsPointInTrigger",
      "arguments": [
        {
          "name": "trigger",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "point",
          "desc": "Word space point as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "inside",
          "desc": "True if point is in trigger volume",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local p = Vec(0, 10, 0)\nif IsPointInTrigger(trigger, p) then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "IsTriggerEmpty",
      "arguments": [
        {
          "name": "handle",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "demolision",
          "desc": "If true, small debris and vehicles are ignored",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "empty",
          "desc": "True if trigger is empty",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "maxpoint",
          "desc": "World space point of highest point (largest Y coordinate) if not empty",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local empty, highPoint = IsTriggerEmpty(trigger)\nif not empty then\n\t--highPoint[2] is the tallest point in trigger\nend"
      ],
      "description": "This function will check if trigger is empty. If trigger contains any part of a\nbody it will return false and the highest point as second return value.",
      "tables": {}
    },
    {
      "name": "GetTriggerDistance",
      "arguments": [
        {
          "name": "trigger",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "point",
          "desc": "Word space point as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "distance",
          "desc": "Positive if point is outside, negative if inside",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local p = Vec(0, 10, 0)\nlocal dist = GetTriggerDistance(trigger, p)"
      ],
      "description": "Get distance to the surface of trigger volume. Will return negative distance if\ninside.",
      "tables": {}
    },
    {
      "name": "GetTriggerClosestPoint",
      "arguments": [
        {
          "name": "trigger",
          "desc": "Trigger handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "point",
          "desc": "Word space point as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "closest",
          "desc": "Closest point in trigger as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local p = Vec(0, 10, 0)\nlocal closest = GetTriggerClosestPoint(trigger, p)"
      ],
      "description": "Return closest point in trigger volume. Will return the input point itself if\ninside trigger or closest point on surface of trigger if outside.",
      "tables": {}
    },
    {
      "name": "FindScreen",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to first screen with specified tag or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local screen = FindTrigger(\"tv\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindScreens",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all screens with specified tag",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Find screens tagged \"tv\" in script scope\nlocal screens = FindScreens(\"tv\")\nfor i=1, #screens do\n\tlocal screen = screens[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetScreenEnabled",
      "arguments": [
        {
          "name": "screen",
          "desc": "Screen handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "enabled",
          "desc": "True if screen should be enabled",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "SetScreenEnabled(screen, true)"
      ],
      "description": "Enable or disable screen",
      "tables": {}
    },
    {
      "name": "IsScreenEnabled",
      "arguments": [
        {
          "name": "screen",
          "desc": "Screen handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "enabled",
          "desc": "True if screen is enabled",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "local b = IsScreenEnabled(screen)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetScreenShape",
      "arguments": [
        {
          "name": "screen",
          "desc": "Screen handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "shape",
          "desc": "Shape handle or zero if none",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local shape = GetScreenShape(screen)"
      ],
      "description": "Return handle to the parent shape of a screen",
      "tables": {}
    },
    {
      "name": "FindVehicle",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to first vehicle with specified tag or zero if not found",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local vehicle = FindVehicle(\"mycar\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "FindVehicles",
      "arguments": [
        {
          "name": "tag",
          "desc": "Tag name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "global",
          "desc": "Search in entire scene",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all vehicles with specified tag",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "--Find all vehicles in level tagged \"boat\"\nlocal boats = FindVehicles(\"boat\")\nfor i=1, #boats do\n\tlocal boat = boats[i]\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetVehicleTransform",
      "arguments": [
        {
          "name": "vehicle",
          "desc": "Vehicle handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "Transform of vehicle",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetVehicleTransform(vehicle)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetVehicleBody",
      "arguments": [
        {
          "name": "vehicle",
          "desc": "Vehicle handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "body",
          "desc": "Main body of vehicle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local body = GetVehicleBody(vehicle)\nif IsBodyBroken(body) then\n--Vehicle body is broken\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetVehicleHealth",
      "arguments": [
        {
          "name": "vehicle",
          "desc": "Vehicle handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "health",
          "desc": "Vehicle health (zero to one)",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local health = GetVehicleHealth(vehicle)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetVehicleDriverPos",
      "arguments": [
        {
          "name": "vehicle",
          "desc": "Vehicle handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "pos",
          "desc": "Driver position as vector in vehicle space",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local driverPos = GetVehicleDriverPos(vehicle)\nlocal t = GetVehicleTransform(vehicle)\nlocal worldPos = TransformToParentPoint(t, driverPos)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "DriveVehicle",
      "arguments": [
        {
          "name": "vehicle",
          "desc": "Vehicle handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "drive",
          "desc": "Reverse/forward control -1 to 1",
          "optional": false,
          "type": "number"
        },
        {
          "name": "steering",
          "desc": "Left/right control -1 to 1",
          "optional": false,
          "type": "number"
        },
        {
          "name": "handbrake",
          "desc": "Handbrake control",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "function tick()\n\t--Drive mycar forwards\n\tlocal v = FindVehicle(\"mycar\")\n\tDriveVehicle(v, 1, 0, false)\nend"
      ],
      "description": "This function applies input to vehicles, allowing for autonomous driving. The\nvehicle will be turned on automatically and turned off when no longer called.\nCall this from the tick function, not update.",
      "tables": {}
    },
    {
      "name": "GetPlayerPos",
      "arguments": [],
      "returns": [
        {
          "name": "position",
          "desc": "Player center position",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local p = GetPlayerPos()\n\n--This is equivalent to\np = VecAdd(GetPlayerTransform().pos, Vec(0,1,0))"
      ],
      "description": "Return center point of player. This function is deprecated. Use\nGetPlayerTransform instead.",
      "tables": {}
    },
    {
      "name": "GetPlayerTransform",
      "arguments": [
        {
          "name": "includePitch",
          "desc": "Include the player pitch (look up/down) in transform",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "transform",
          "desc": "Current player transform",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetPlayerTransform()"
      ],
      "description": "The player transform is located at the bottom of the player. The player\ntransform considers heading (looking left and right). Forward is along negative\nZ axis. Player pitch (looking up and down) does not affect player transform\nunless includePitch is set to true. If you want the transform of the eye, use\nGetPlayerCameraTransform() instead.",
      "tables": {}
    },
    {
      "name": "SetPlayerTransform",
      "arguments": [
        {
          "name": "transform",
          "desc": "Desired player transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "includePitch",
          "desc": "Set player pitch (look up/down) as well",
          "optional": false,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "local t = Transform(Vec(10, 0, 0), QuatEuler(0, 90, 0))\nSetPlayerTransform(t)"
      ],
      "description": "Instantly teleport the player to desired transform. Unless includePitch is set\nto true, up/down look angle will be set to zero during this process. Player\nvelocity will be reset to zero.",
      "tables": {}
    },
    {
      "name": "SetPlayerGroundVelocity",
      "arguments": [
        {
          "name": "vel",
          "desc": "Desired ground velocity",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "SetPlayerGroundVelocity(Vec(2,0,0))"
      ],
      "description": "Make the ground act as a conveyor belt, pushing the player even if ground shape\nis static.",
      "tables": {}
    },
    {
      "name": "GetPlayerCameraTransform",
      "arguments": [],
      "returns": [
        {
          "name": "transform",
          "desc": "Current player camera transform",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetPlayerCameraTransform()"
      ],
      "description": "The player camera transform is usually the same as what you get from\nGetCameraTransform, but if you have set a camera transform manually with\nSetCameraTransform, you can retrieve the standard player camera transform with\nthis function.",
      "tables": {}
    },
    {
      "name": "SetPlayerCameraOffsetTransform",
      "arguments": [
        {
          "name": "transform",
          "desc": "Desired player camera offset transform",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "local t = Transform(Vec(), QuatAxisAngle(Vec(1, 0, 0), math.sin(time*3.0) * 3.0))\nSetPlayerCameraOffsetTransform(t)"
      ],
      "description": "Call this function continously to apply a camera offset. Can be used for camera\neffects such as shake and wobble.",
      "tables": {}
    },
    {
      "name": "SetPlayerSpawnTransform",
      "arguments": [
        {
          "name": "transform",
          "desc": "Desired player spawn transform",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "local t = Transform(Vec(10, 0, 0), QuatEuler(0, 90, 0))\nSetPlayerSpawnTransform(t)"
      ],
      "description": "Call this function during init to alter the player spawn transform.",
      "tables": {}
    },
    {
      "name": "GetPlayerVelocity",
      "arguments": [],
      "returns": [
        {
          "name": "velocity",
          "desc": "Player velocity in world space as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local vel = GetPlayerVelocity()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetPlayerVehicle",
      "arguments": [
        {
          "name": "vehicle",
          "desc": "Handle to vehicle or zero to not drive.",
          "optional": false,
          "type": "value"
        }
      ],
      "returns": [],
      "examples": [
        "local car = FindVehicle(\"mycar\")\nSetPlayerVehicle(car)"
      ],
      "description": "Drive specified vehicle.",
      "tables": {}
    },
    {
      "name": "SetPlayerVelocity",
      "arguments": [
        {
          "name": "velocity",
          "desc": "Player velocity in world space as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "SetPlayerVelocity(Vec(0, 5, 0))"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetPlayerVehicle",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Current vehicle handle, or zero if not in vehicle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local vehicle = GetPlayerVehicle()\nif vehicle ~= 0 then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetPlayerGrabShape",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to grabbed shape or zero if not grabbing.",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local shape = GetPlayerGrabShape()\nif shape ~= 0 then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetPlayerGrabBody",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to grabbed body or zero if not grabbing.",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local body = GetPlayerGrabBody()\nif body ~= 0 then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "ReleasePlayerGrab",
      "arguments": [],
      "returns": [],
      "examples": [
        "ReleasePlayerGrab()"
      ],
      "description": "Release what the player is currently holding",
      "tables": {}
    },
    {
      "name": "GetPlayerPickShape",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to picked shape or zero if nothing is picked",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local shape = GetPlayerPickShape()\nif shape ~= 0 then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetPlayerPickBody",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to picked body or zero if nothing is picked",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local body = GetPlayerPickBody()\nif body ~= 0 then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetPlayerInteractShape",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to interactable shape or zero",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local shape = GetPlayerInteractShape()\nif shape ~= 0 then\n\t...\nend"
      ],
      "description": "Interactable shapes has to be tagged with \"interact\". The engine determines\nwhich interactable shape is currently interactable.",
      "tables": {}
    },
    {
      "name": "GetPlayerInteractBody",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to interactable body or zero",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local body = GetPlayerInteractBody()\nif body ~= 0 then\n\t...\nend"
      ],
      "description": "Interactable shapes has to be tagged with \"interact\". The engine determines\nwhich interactable body is currently interactable.",
      "tables": {}
    },
    {
      "name": "SetPlayerScreen",
      "arguments": [
        {
          "name": "handle",
          "desc": "Handle to screen or zero for no screen",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Interact with screen\nSetPlayerScreen(screen)\n\n--Do not interact with screen\nSetPlayerScreen(0)"
      ],
      "description": "Set the screen the player should interact with. For the screen to feature a\nmouse pointer and receieve input, the screen also needs to have interactive\nproperty.",
      "tables": {}
    },
    {
      "name": "GetPlayerScreen",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to interacted screen or zero if none",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Interact with screen\nlocal screen = GetPlayerScreen()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetPlayerHealth",
      "arguments": [
        {
          "name": "health",
          "desc": "Set player health (between zero and one)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "SetPlayerHealth(0.5)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetPlayerHealth",
      "arguments": [],
      "returns": [
        {
          "name": "health",
          "desc": "Current player health",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local health = GetPlayerHealth()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "RespawnPlayer",
      "arguments": [],
      "returns": [],
      "examples": [
        "RespawnPlayer()"
      ],
      "description": "Respawn player at spawn position without modifying the scene",
      "tables": {}
    },
    {
      "name": "RegisterTool",
      "arguments": [
        {
          "name": "id",
          "desc": "Tool unique identifier",
          "optional": false,
          "type": "string"
        },
        {
          "name": "name",
          "desc": "Tool name to show in hud",
          "optional": false,
          "type": "string"
        },
        {
          "name": "file",
          "desc": "Path to vox file",
          "optional": false,
          "type": "string"
        },
        {
          "name": "group",
          "desc": "Tool group for this tool (1-6) Default is 6.",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "function init()\n\tRegisterTool(\"lasergun\", \"Laser Gun\", \"MOD/vox/lasergun.vox\")\n\tSetBool(\"game.tool.lasergun.enabled\", true)\nend\n\nfunction tick()\n\tif GetString(\"game.player.tool\") == \"lasergun\" then\n\t\t--Tool is selected. Tool logic goes here.\n\tend\nend"
      ],
      "description": "Register a custom tool that will show up in the player inventory and can be\nselected with scroll wheel. Do this only once per tool. You also need to enable\nthe tool in the registry before it can be used.",
      "tables": {}
    },
    {
      "name": "GetToolBody",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to currently visible tool body or zero if none",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local toolBody = GetToolBody()\nif toolBody~=0 then\n\t...\nend"
      ],
      "description": "Return body handle of the visible tool. You can use this to retrieve tool shapes\nand animate them, change emissiveness, etc. Do not attempt to set the tool body\ntransform, since it is controlled by the engine. Use SetToolTranform for that.",
      "tables": {}
    },
    {
      "name": "SetToolTransform",
      "arguments": [
        {
          "name": "transform",
          "desc": "Tool body transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "sway",
          "desc": "Tool sway amount. Default is 1.0.",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Offset the tool half a meter to the right\nlocal offset = Transform(Vec(0.5, 0, 0))\nSetToolTransform(offset)"
      ],
      "description": "Apply an additional transform on the visible tool body. This can be used to\ncreate tool animations. You need to set this every frame from the tick function.\nThe optional sway parameter control the amount of tool swaying when walking. Set\nto zero to disable completely.",
      "tables": {}
    },
    {
      "name": "LoadSound",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to ogg sound file",
          "optional": false,
          "type": "string"
        },
        {
          "name": "nominalDistance",
          "desc": "The distance in meters this sound is recorded at. Affects attenuation, default is 10.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Sound handle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local snd = LoadSound(\"beep.ogg\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "LoadLoop",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to ogg sound file",
          "optional": false,
          "type": "string"
        },
        {
          "name": "nominalDistance",
          "desc": "The distance in meters this sound is recorded at. Affects attenuation, default is 10.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Loop handle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local loop = LoadLoop(\"siren.ogg\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "PlaySound",
      "arguments": [
        {
          "name": "handle",
          "desc": "Sound handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "pos",
          "desc": "World position as vector. Default is player position.",
          "optional": true,
          "type": "table"
        },
        {
          "name": "volume",
          "desc": "Playback volume. Default is 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "function init()\n\tsnd = LoadSound(\"beep.ogg\")\nend\n\nfunction tick()\n\tif trigSound then\n\t\tlocal pos = Vec(100, 0, 0)\n\t\tPlaySound(snd, pos, 0.5)\n\tend\nend\n\nIf you have a list of sound files and you add a sequence number, starting from zero, at the end of each filename like below,\nthen each time you call PlaySound it will pick a random sound from that list and play that sound.\n\n\"example-sound0.ogg\"\n\"example-sound1.ogg\"\n\"example-sound2.ogg\"\n\"example-sound3.ogg\"\n...\n\nfunction init()\n\t--Load sound serie, OBS no \".ogg\" or sequence number in filename\n\tsnd = LoadSound(\"example-sound\")\nend\n\nPlays a random sound from the loaded sound series\nfunction tick()\n\tif trigSound then\n\t\tlocal pos = Vec(100, 0, 0)\n\t\tPlaySound(snd, pos, 0.5)\n\tend\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "PlayLoop",
      "arguments": [
        {
          "name": "handle",
          "desc": "Loop handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "pos",
          "desc": "World position as vector. Default is player position.",
          "optional": true,
          "type": "table"
        },
        {
          "name": "volume",
          "desc": "Playback volume. Default is 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "function init()\n\tloop = LoadLoop(\"siren.ogg\")\nend\n\nfunction tick()\n\tlocal pos = Vec(100, 0, 0)\n\tPlayLoop(loop, pos, 0.5)\nend"
      ],
      "description": "Call this function continuously to play loop",
      "tables": {}
    },
    {
      "name": "PlayMusic",
      "arguments": [
        {
          "name": "path",
          "desc": "Music path",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "PlayMusic(\"MOD/music/background.ogg\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "StopMusic",
      "arguments": [],
      "returns": [],
      "examples": [
        "StopMusic()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "LoadSprite",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to sprite. Must be PNG or JPG format.",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "handle",
          "desc": "Sprite handle",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "function init()\n\tarrow = LoadSprite(\"arrow.png\")\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "DrawSprite",
      "arguments": [
        {
          "name": "handle",
          "desc": "Sprite handle",
          "optional": false,
          "type": "number"
        },
        {
          "name": "transform",
          "desc": "Transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "width",
          "desc": "Width in meters",
          "optional": false,
          "type": "number"
        },
        {
          "name": "height",
          "desc": "Height in meters",
          "optional": false,
          "type": "number"
        },
        {
          "name": "r",
          "desc": "Red color. Default 1.0.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green color. Default 1.0.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue color. Default 1.0.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha. Default 1.0.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "depthTest",
          "desc": "Depth test enabled. Default false.",
          "optional": true,
          "type": "boolean"
        },
        {
          "name": "additive",
          "desc": "Additive blending enabled. Default false.",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "function init()\n\tarrow = LoadSprite(\"arrow.png\")\nend\n\nfunction tick()\n\t--Draw sprite using transform\n\t--Size is two meters in width and height\n\t--Color is white, fully opaue\n\tlocal t = Transform(Vec(0, 10, 0), QuatEuler(0, GetTime(), 0))\n\tDrawSprite(arrow, t, 2, 2, 1, 1, 1, 1)\nend"
      ],
      "description": "Draw sprite in world at next frame. Call this function from the tick callback.",
      "tables": {}
    },
    {
      "name": "QueryRequire",
      "arguments": [
        {
          "name": "layers",
          "desc": "Space separate list of layers",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "--Raycast dynamic, physical objects above debris threshold, but not specific vehicle\nQueryRequire(\"physical dynamic large\")\nQueryRejectVehicle(vehicle)\nQueryRaycast(...)"
      ],
      "description": "Set required layers for next query. Available layers are: ${table:Layer}",
      "tables": {
        "Layer": [
          [
            "physical",
            "have a physical representation"
          ],
          [
            "dynamic",
            "part of a dynamic body"
          ],
          [
            "static",
            "part of a static body"
          ],
          [
            "large",
            "above debris threshold"
          ],
          [
            "small",
            "below debris threshold"
          ],
          [
            "visible",
            "only hit visible shapes"
          ]
        ]
      }
    },
    {
      "name": "QueryRejectVehicle",
      "arguments": [
        {
          "name": "vehicle",
          "desc": "Vehicle handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Do not include vehicle in next raycast\nQueryRejectVehicle(vehicle)\nQueryRaycast(...)"
      ],
      "description": "Exclude vehicle from the next query",
      "tables": {}
    },
    {
      "name": "QueryRejectBody",
      "arguments": [
        {
          "name": "body",
          "desc": "Body handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Do not include body in next raycast\nQueryRejectBody(body)\nQueryRaycast(...)"
      ],
      "description": "Exclude body from the next query",
      "tables": {}
    },
    {
      "name": "QueryRejectShape",
      "arguments": [
        {
          "name": "shape",
          "desc": "Shape handle",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Do not include shape in next raycast\nQueryRejectShape(shape)\nQueryRaycast(...)"
      ],
      "description": "Exclude shape from the next query",
      "tables": {}
    },
    {
      "name": "QueryRaycast",
      "arguments": [
        {
          "name": "origin",
          "desc": "Raycast origin as world space vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "direction",
          "desc": "Unit length raycast direction as world space vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "maxDist",
          "desc": "Raycast maximum distance. Keep this as low as possible for good performance.",
          "optional": false,
          "type": "number"
        },
        {
          "name": "radius",
          "desc": "Raycast thickness. Default zero.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "rejectTransparent",
          "desc": "Raycast through transparent materials. Default false.",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "hit",
          "desc": "True if raycast hit something",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "dist",
          "desc": "Hit distance from origin",
          "optional": false,
          "type": "number"
        },
        {
          "name": "normal",
          "desc": "World space normal at hit point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "shape",
          "desc": "Handle to hit shape",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Raycast from a high point straight downwards, excluding a specific vehicle\nQueryRejectVehicle(vehicle)\nlocal hit, d = QueryRaycast(Vec(0, 100, 0), Vec(0, -1, 0), 100)\nif hit then\n\t...hit something at distance d\nend"
      ],
      "description": "This will perform a raycast or spherecast (if radius is more than zero) query.\nIf you want to set up a filter for the query you need to do so before every call\nto this function.",
      "tables": {}
    },
    {
      "name": "QueryClosestPoint",
      "arguments": [
        {
          "name": "origin",
          "desc": "World space point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "maxDist",
          "desc": "Maximum distance. Keep this as low as possible for good performance.",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "hit",
          "desc": "True if a point was found",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "point",
          "desc": "World space closest point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "normal",
          "desc": "World space normal at closest point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "shape",
          "desc": "Handle to closest shape",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Find closest point within 10 meters of {0, 5, 0}, excluding any point on myVehicle\nQueryRejectVehicle(myVehicle)\nlocal hit, p, n, s = QueryClosestPoint(Vec(0, 5, 0), 10)\nif hit then\n\t--Point p of shape s is closest\nend"
      ],
      "description": "This will query the closest point to all shapes in the world. If you want to set\nup a filter for the query you need to do so before every call to this function.",
      "tables": {}
    },
    {
      "name": "QueryAabbShapes",
      "arguments": [
        {
          "name": "min",
          "desc": "Aabb minimum point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "max",
          "desc": "Aabb maximum point",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all shapes in the aabb",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local list = QueryAabbShapes(Vec(0, 0, 0), Vec(10, 10, 10))\nfor i=1, #list do\n\tlocal shape = list[i]\n\t..\nend"
      ],
      "description": "Return all shapes within the provided world space, axis-aligned bounding box",
      "tables": {}
    },
    {
      "name": "QueryAabbBodies",
      "arguments": [
        {
          "name": "min",
          "desc": "Aabb minimum point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "max",
          "desc": "Aabb maximum point",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "list",
          "desc": "Indexed table with handles to all bodies in the aabb",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local list = QueryAabbBodies(Vec(0, 0, 0), Vec(10, 10, 10))\nfor i=1, #list do\n\tlocal body = list[i]\n\t..\nend"
      ],
      "description": "Return all bodies within the provided world space, axis-aligned bounding box",
      "tables": {}
    },
    {
      "name": "QueryPath",
      "arguments": [
        {
          "name": "start",
          "desc": "World space start point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "end",
          "desc": "World space target point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "maxDist",
          "desc": "Maximum path length before giving up. Default is infinite.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "targetRadius",
          "desc": "Maximum allowed distance to target in meters. Default is 2.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "QueryPath(Vec(-10, 0, 0), Vec(10, 0, 0))"
      ],
      "description": "Initiate path planning query. The result will run asynchronously as long as\nGetPathState retuns \"busy\". An ongoing path query can be aborted with AbortPath.\nThe path planning query will use the currently set up query filter, just like\nthe other query functions.",
      "tables": {}
    },
    {
      "name": "AbortPath",
      "arguments": [],
      "returns": [],
      "examples": [
        "AbortPath()"
      ],
      "description": "Abort current path query, regardless of what state it is currently in. This is a\nway to save computing resources if the result of the current query is no longer\nof interest.",
      "tables": {}
    },
    {
      "name": "GetPathState",
      "arguments": [],
      "returns": [
        {
          "name": "state",
          "desc": "Current path planning state",
          "optional": false,
          "type": "string"
        }
      ],
      "examples": [
        "local s = GetPathState()\nif s == \"done\" then\n\tDoSomething()\nend"
      ],
      "description": "Return the current state of the last path planning query. ${table:State}",
      "tables": {
        "State": [
          [
            "idle",
            "No recent query"
          ],
          [
            "busy",
            "Busy computing. No path found yet."
          ],
          [
            "fail",
            "Failed to find path. You can still get the resulting path (even though it won't reach the target)."
          ],
          [
            "done",
            "Path planning completed and a path was found. Get it with GetPathLength and GetPathPoint)"
          ]
        ]
      }
    },
    {
      "name": "GetPathLength",
      "arguments": [],
      "returns": [
        {
          "name": "length",
          "desc": "Length of last path planning result (in meters)",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local l = GetPathLength()"
      ],
      "description": "Return the path length of the most recently computed path query. Note that the\nresult can often be retrieved even if the path query failed. If the target point\ncouldn't be reached, the path endpoint will be the point closest to the target.",
      "tables": {}
    },
    {
      "name": "GetPathPoint",
      "arguments": [
        {
          "name": "dist",
          "desc": "The distance along path. Should be between zero and result from GetPathLength()",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "point",
          "desc": "The path point dist meters along the path",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local d = 0\nlocal l = GetPathLength()\nwhile d < l do\n\tDebugCross(GetPathPoint(d))\n\td = d + 0.5\nend"
      ],
      "description": "Return a point along the path for the most recently computed path query. Note\nthat the result can often be retrieved even if the path query failed. If the\ntarget point couldn't be reached, the path endpoint will be the point closest to\nthe target.",
      "tables": {}
    },
    {
      "name": "GetLastSound",
      "arguments": [],
      "returns": [
        {
          "name": "volume",
          "desc": "Volume of loudest sound played last frame",
          "optional": false,
          "type": "number"
        },
        {
          "name": "position",
          "desc": "World position of loudest sound played last frame",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local vol, pos = GetLastSound()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "IsPointInWater",
      "arguments": [
        {
          "name": "point",
          "desc": "World point as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "inWater",
          "desc": "True if point is in water",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "depth",
          "desc": "Depth of point into water, or zero if not in water",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local wet, d = IsPointInWater(Vec(10, 0, 0))\nif wet then\n\t...point d meters into water\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetWindVelocity",
      "arguments": [
        {
          "name": "point",
          "desc": "World point as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "vel",
          "desc": "Wind at provided position",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local v = GetWindVelocity(Vec(0, 10, 0))"
      ],
      "description": "Get the wind velocity at provided point. The wind will be determined by wind\nproperty of the environment, but it varies with position procedurally.",
      "tables": {}
    },
    {
      "name": "ParticleReset",
      "arguments": [],
      "returns": [],
      "examples": [
        "ParticleReset()"
      ],
      "description": "Reset to default particle state, which is a plain, white particle of radius 0.5.\nCollision is enabled and it alpha animates from 1 to 0.",
      "tables": {}
    },
    {
      "name": "ParticleType",
      "arguments": [
        {
          "name": "type",
          "desc": "Type of particle. Can be \"smoke\" or \"plain\".",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "ParticleType(\"smoke\")"
      ],
      "description": "Set type of particle",
      "tables": {}
    },
    {
      "name": "ParticleTile",
      "arguments": [
        {
          "name": "type",
          "desc": "Tile in the particle texture atlas (0-15)",
          "optional": false,
          "type": "int"
        }
      ],
      "returns": [],
      "examples": [
        "--Smoke particle\nParticleTile(0)\n\n--Fire particle\nParticleTile(5)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "ParticleColor",
      "arguments": [
        {
          "name": "r0",
          "desc": "Red value",
          "optional": false,
          "type": "float"
        },
        {
          "name": "g0",
          "desc": "Green value",
          "optional": false,
          "type": "float"
        },
        {
          "name": "b0",
          "desc": "Blue value",
          "optional": false,
          "type": "float"
        },
        {
          "name": "r1",
          "desc": "Red value at end",
          "optional": true,
          "type": "float"
        },
        {
          "name": "g1",
          "desc": "Green value at end",
          "optional": true,
          "type": "float"
        },
        {
          "name": "b1",
          "desc": "Blue value at end",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Constant red\nParticleColor(1,0,0)\n\n--Animating from yellow to red\nParticleColor(1,1,0, 1,0,0)"
      ],
      "description": "Set particle color to either constant (three arguments) or linear interpolation\n(six arguments)",
      "tables": {}
    },
    {
      "name": "ParticleRadius",
      "arguments": [
        {
          "name": "r0",
          "desc": "Radius",
          "optional": false,
          "type": "float"
        },
        {
          "name": "r1",
          "desc": "End radius",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Constant radius 0.4 meters\nParticleRadius(0.4)\n\n--Interpolate from small to large\nParticleRadius(0.1, 0.7)"
      ],
      "description": "Set the particle radius. Max radius for smoke particles is 1.0.",
      "tables": {}
    },
    {
      "name": "ParticleAlpha",
      "arguments": [
        {
          "name": "a0",
          "desc": "Alpha (0.0 - 1.0)",
          "optional": false,
          "type": "float"
        },
        {
          "name": "a1",
          "desc": "End alpha (0.0 - 1.0)",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Interpolate from opaque to transparent\nParticleAlpha(1.0, 0.0)"
      ],
      "description": "Set the particle alpha (opacity).",
      "tables": {}
    },
    {
      "name": "ParticleGravity",
      "arguments": [
        {
          "name": "g0",
          "desc": "Gravity",
          "optional": false,
          "type": "float"
        },
        {
          "name": "g1",
          "desc": "End gravity",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Move particles slowly upwards\nParticleGravity(2)"
      ],
      "description": "Set particle gravity. It will be applied along the world Y axis. A negative\nvalue will move the particle downwards.",
      "tables": {}
    },
    {
      "name": "ParticleDrag",
      "arguments": [
        {
          "name": "d0",
          "desc": "Drag",
          "optional": false,
          "type": "float"
        },
        {
          "name": "d1",
          "desc": "End drag",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Slow down fast moving particles\nParticleDrag(0.5)"
      ],
      "description": "Particle drag will slow down fast moving particles. It's implemented slightly\ndifferent for smoke and plain particles. Drag must be positive, and usually look\ngood between zero and one.",
      "tables": {}
    },
    {
      "name": "ParticleEmissive",
      "arguments": [
        {
          "name": "d0",
          "desc": "Emissive",
          "optional": false,
          "type": "float"
        },
        {
          "name": "d1",
          "desc": "End emissive",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Highly emissive at start, not emissive at end\nParticleEmissive(5, 0)"
      ],
      "description": "Draw particle as emissive (glow in the dark). This is useful for fire and\nembers.",
      "tables": {}
    },
    {
      "name": "ParticleRotation",
      "arguments": [
        {
          "name": "r0",
          "desc": "Rotation speed in radians per second.",
          "optional": false,
          "type": "float"
        },
        {
          "name": "r1",
          "desc": "End rotation speed in radians per second.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Rotate fast at start and slow at end\nParticleRotation(10, 1)"
      ],
      "description": "Makes the particle rotate. Positive values is counter-clockwise rotation.",
      "tables": {}
    },
    {
      "name": "ParticleStretch",
      "arguments": [
        {
          "name": "s0",
          "desc": "Stretch",
          "optional": false,
          "type": "float"
        },
        {
          "name": "s1",
          "desc": "End stretch",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Stretch particle along direction of motion\nParticleStretch(1.0)"
      ],
      "description": "Stretch particle along with velocity. 0.0 means no stretching. 1.0 stretches\nwith the particle motion over one frame. Larger values stretches the particle\neven more.",
      "tables": {}
    },
    {
      "name": "ParticleSticky",
      "arguments": [
        {
          "name": "s0",
          "desc": "Sticky (0.0 - 1.0)",
          "optional": false,
          "type": "float"
        },
        {
          "name": "s1",
          "desc": "End sticky (0.0 - 1.0)",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Make particles stick to objects\nParticleSticky(0.5)"
      ],
      "description": "Make particle stick when in contact with objects. This can be used for friction.",
      "tables": {}
    },
    {
      "name": "ParticleCollide",
      "arguments": [
        {
          "name": "c0",
          "desc": "Collide (0.0 - 1.0)",
          "optional": false,
          "type": "float"
        },
        {
          "name": "c1",
          "desc": "End collide (0.0 - 1.0)",
          "optional": true,
          "type": "float"
        },
        {
          "name": "interpolation",
          "desc": "Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "fadein",
          "desc": "Fade in between t=0 and t=fadein. Default is zero.",
          "optional": true,
          "type": "float"
        },
        {
          "name": "fadeout",
          "desc": "Fade out between t=fadeout and t=1. Default is one.",
          "optional": true,
          "type": "float"
        }
      ],
      "returns": [],
      "examples": [
        "--Disable collisions\nParticleCollide(0)\n\n--Enable collisions over time\nParticleCollide(0, 1)\n\n--Ramp up collisions very quickly, only skipping the first 5% of lifetime\nParticleCollide(1, 1, \"constant\", 0.05)"
      ],
      "description": "Control particle collisions. A value of zero means that collisions are ignored.\nOne means full collision. It is sometimes useful to animate this value from zero\nto one in order to not collide with objects around the emitter.",
      "tables": {}
    },
    {
      "name": "ParticleFlags",
      "arguments": [
        {
          "name": "bitmask",
          "desc": "Particle flags (bitmask 0-65535)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Fire extinguishing particle\nParticleFlags(256)\nSpawnParticle(...)"
      ],
      "description": "Set particle bitmask. The value 256 means fire extinguishing particles and is\ncurrently the only flag in use. There might be support for custom flags and\nqueries in the future.",
      "tables": {}
    },
    {
      "name": "SpawnParticle",
      "arguments": [
        {
          "name": "pos",
          "desc": "World space point as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "velocity",
          "desc": "World space velocity as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "lifetime",
          "desc": "Particle lifetime in seconds",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "ParticleReset()\nParticleType(\"smoke\")\nParticleColor(0.7, 0.6, 0.5)\n--Spawn particle at world origo with upwards velocity and a lifetime of ten seconds\nSpawnParticle(Vec(0, 0, 0), Vec(0, 1, 0), 10.0)"
      ],
      "description": "Spawn particle using the previously set up particle state. You can call this\nmultiple times using the same particle state, but with different position,\nvelocity and lifetime. You can also modify individual properties in the particle\nstate in between calls to to this function.",
      "tables": {}
    },
    {
      "name": "Spawn",
      "arguments": [
        {
          "name": "xml",
          "desc": "File name or xml string",
          "optional": false,
          "type": "string"
        },
        {
          "name": "transform",
          "desc": "Spawn transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "allowStatic",
          "desc": "Allow spawning static shapes and bodies (default false)",
          "optional": true,
          "type": "boolean"
        },
        {
          "name": "jointExisting",
          "desc": "Allow joints to connect to existing scene geometry (default false)",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "entities",
          "desc": "Indexed table with handles to all spawned entities",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "Spawn(\"MOD/prefab/mycar.xml\", Transform(Vec(0, 5, 0)))\nSpawn(\"<voxbox size='10 10 10' prop='true' material='wood'/>\", Transform(Vec(0, 10, 0)))"
      ],
      "description": "The first argument can be either a prefab XML file in your mod folder or a\nstring with XML content. It is also possible to spawn prefabs from other mods,\nby using the mod id followed by colon, followed by the prefab path. Spawning\nprefabs from other mods should be used with causion since the referenced mod\nmight not be installed.",
      "tables": {}
    },
    {
      "name": "Shoot",
      "arguments": [
        {
          "name": "origin",
          "desc": "Origin in world space as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "direction",
          "desc": "Unit length direction as world space vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "type",
          "desc": "Shot type, see description, default is \"bullet\"",
          "optional": true,
          "type": "string"
        },
        {
          "name": "strength",
          "desc": "Strength scaling, default is 1.0",
          "optional": true,
          "type": "number"
        },
        {
          "name": "maxDist",
          "desc": "Maximum distance, default is 100.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "Shoot(Vec(0, 10, 0), Vec(0, 0, 1), \"shotgun\")"
      ],
      "description": "Fire projectile. Type can be one of \"bullet\", \"rocket\", \"gun\" or \"shotgun\". For\nbackwards compatilbility, type also accept a number, where 1 is same as \"rocket\"\nand anything else \"bullet\" Note that this function will only spawn the\nprojectile, not make any sound Also note that \"bullet\" and \"rocket\" are the only\nprojectiles that can hurt the player.",
      "tables": {}
    },
    {
      "name": "Paint",
      "arguments": [
        {
          "name": "origin",
          "desc": "Origin in world space as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "radius",
          "desc": "Affected radius, in range 0.0 to 5.0",
          "optional": false,
          "type": "number"
        },
        {
          "name": "type",
          "desc": "Paint type. Can be \"explosion\" or \"spraycan\". Default is spraycan.",
          "optional": true,
          "type": "string"
        },
        {
          "name": "probability",
          "desc": "Dithering probability between zero and one, default is 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "Paint(Vec(0, 10, 0), 0.5, \"spraycan\")"
      ],
      "description": "Tint the color of objects within radius to either black or yellow.",
      "tables": {}
    },
    {
      "name": "MakeHole",
      "arguments": [
        {
          "name": "position",
          "desc": "Hole center point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "r0",
          "desc": "Hole radius for soft materials",
          "optional": false,
          "type": "number"
        },
        {
          "name": "r1",
          "desc": "Hole radius for medium materials. May not be bigger than r0. Default zero.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "r2",
          "desc": "Hole radius for hard materials. May not be bigger than r1. Default zero.",
          "optional": true,
          "type": "number"
        },
        {
          "name": "silent",
          "desc": "Make hole without playing any break sounds.",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "count",
          "desc": "Number of voxels that was cut out. This will be zero if there were no changes to any shape.",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "MakeHole(pos, 1.2, 1.0)"
      ],
      "description": "Make a hole in the environment. Radius is given in meters. Soft materials:\nglass, foliage, dirt, wood, plaster and plastic. Medium materials: concrete,\nbrick and weak metal. Hard materials: hard metal and hard masonry.",
      "tables": {}
    },
    {
      "name": "Explosion",
      "arguments": [
        {
          "name": "pos",
          "desc": "Position in world space as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "size",
          "desc": "Explosion size from 0.5 to 4.0",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "Explosion(Vec(0, 10, 0), 1)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SpawnFire",
      "arguments": [
        {
          "name": "pos",
          "desc": "Position in world space as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [],
      "examples": [
        "SpawnFire(Vec(0, 10, 0))"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetFireCount",
      "arguments": [],
      "returns": [
        {
          "name": "count",
          "desc": "Number of active fires in level",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local c = GetFireCount()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "QueryClosestFire",
      "arguments": [
        {
          "name": "origin",
          "desc": "World space position as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "maxDist",
          "desc": "Maximum search distance",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "hit",
          "desc": "A fire was found within search distance",
          "optional": false,
          "type": "boolean"
        },
        {
          "name": "pos",
          "desc": "Position of closest fire",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local hit, pos = QueryClosestFire(GetPlayerTransform().pos, 5.0)\nif hit then\n\t--There is a fire within 5 meters to the player. Mark it with a debug cross.\n\tDebugCross(pos)\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "QueryAabbFireCount",
      "arguments": [
        {
          "name": "min",
          "desc": "Aabb minimum point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "max",
          "desc": "Aabb maximum point",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "count",
          "desc": "Number of active fires in bounding box",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local count = QueryAabbFireCount(Vec(0,0,0), Vec(10,10,10))"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "RemoveAabbFires",
      "arguments": [
        {
          "name": "min",
          "desc": "Aabb minimum point",
          "optional": false,
          "type": "table"
        },
        {
          "name": "max",
          "desc": "Aabb maximum point",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "count",
          "desc": "Number of fires removed",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local removedCount= RemoveAabbFires(Vec(0,0,0), Vec(10,10,10))"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "GetCameraTransform",
      "arguments": [],
      "returns": [
        {
          "name": "transform",
          "desc": "Current camera transform",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "local t = GetCameraTransform()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "SetCameraTransform",
      "arguments": [
        {
          "name": "transform",
          "desc": "Desired camera transform",
          "optional": false,
          "type": "table"
        },
        {
          "name": "fov",
          "desc": "Optional horizontal field of view in degrees (default: 90)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "SetCameraTransform(Transform(Vec(0, 10, 0), QuatEuler(0, 90, 0)))"
      ],
      "description": "Override current camera transform for this frame. Call continuously to keep\noverriding.",
      "tables": {}
    },
    {
      "name": "SetCameraFov",
      "arguments": [
        {
          "name": "degrees",
          "desc": "Horizontal field of view in degrees (10-170)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "function tick()\n\tSetCameraFov(60)\nend"
      ],
      "description": "Override field of view for the next frame for all camera modes, except when\nexplicitly set in SetCameraTransform",
      "tables": {}
    },
    {
      "name": "SetCameraDof",
      "arguments": [
        {
          "name": "distance",
          "desc": "Depth of field distance",
          "optional": false,
          "type": "number"
        },
        {
          "name": "amount",
          "desc": "Optional amount of blur (default 1.0)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Set depth of field to 10 meters\nSetCameraDof(10)"
      ],
      "description": "Override depth of field for the next frame for all camera modes. Depth of field\nwill be used even if turned off in options.",
      "tables": {}
    },
    {
      "name": "PointLight",
      "arguments": [
        {
          "name": "pos",
          "desc": "World space light position",
          "optional": false,
          "type": "table"
        },
        {
          "name": "r",
          "desc": "Red",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue",
          "optional": false,
          "type": "number"
        },
        {
          "name": "intensity",
          "desc": "Intensity. Default is 1.0.",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Pulsating, yellow light above world origo\nlocal intensity = 3 + math.sin(GetTime())\nPointLight(Vec(0, 5, 0), 1, 1, 0, intensity)"
      ],
      "description": "Add a temporary point light to the world for this frame. Call continuously for a\nsteady light.",
      "tables": {}
    },
    {
      "name": "SetTimeScale",
      "arguments": [
        {
          "name": "scale",
          "desc": "Time scale 0.1 to 1.0",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Slow down time when holding down a key\nif InputDown('t') then\nSetTimeScale(0.2)\nend"
      ],
      "description": "Experimental. Scale time in order to make a slow-motion effect. Audio will also\nbe affected. Note that this will affect physics behavior and is not intended for\ngameplay purposes. Calling this function will slow down time for the next frame\nonly. Call every frame from tick function to get steady slow-motion.",
      "tables": {}
    },
    {
      "name": "SetEnvironmentDefault",
      "arguments": [],
      "returns": [],
      "examples": [
        "SetEnvironmentDefault()"
      ],
      "description": "Reset the environment properties to default. This is often useful before setting\nup a custom environment.",
      "tables": {}
    },
    {
      "name": "SetEnvironmentProperty",
      "arguments": [
        {
          "name": "name",
          "desc": "Property name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value0",
          "desc": "Property value (type depends on property)",
          "optional": false,
          "type": "varying"
        },
        {
          "name": "value1",
          "desc": "Extra property value (only some properties)",
          "optional": true,
          "type": "varying"
        },
        {
          "name": "value2",
          "desc": "Extra property value (only some properties)",
          "optional": true,
          "type": "varying"
        },
        {
          "name": "value3",
          "desc": "Extra property value (only some properties)",
          "optional": true,
          "type": "varying"
        }
      ],
      "returns": [],
      "examples": [
        "SetEnvironmentProperty(\"skybox\", \"cloudy.dds\")\nSetEnvironmentProperty(\"rain\", 0.7)\nSetEnvironmentProperty(\"fogcolor\", 0.5, 0.5, 0.8)\nSetEnvironmentProperty(\"nightlight\", false)"
      ],
      "description": "This function is used for manipulating the environment properties. The available\nproperties are exactly the same as in the editor, except for \"snowonground\"\nwhich is not currently supported.",
      "tables": {}
    },
    {
      "name": "GetEnvironmentProperty",
      "arguments": [
        {
          "name": "name",
          "desc": "Property name",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value0",
          "desc": "Property value (type depends on property)",
          "optional": false,
          "type": "varying"
        },
        {
          "name": "value1",
          "desc": "Property value (only some properties)",
          "optional": false,
          "type": "varying"
        },
        {
          "name": "value2",
          "desc": "Property value (only some properties)",
          "optional": false,
          "type": "varying"
        },
        {
          "name": "value3",
          "desc": "Property value (only some properties)",
          "optional": false,
          "type": "varying"
        },
        {
          "name": "value4",
          "desc": "Property value (only some properties)",
          "optional": false,
          "type": "varying"
        }
      ],
      "examples": [
        "local skyboxPath = GetEnvironmentProperty(\"skybox\")\nlocal rainValue = GetEnvironmentProperty(\"rain\")\nlocal r,g,b = GetEnvironmentProperty(\"fogcolor\")\nlocal enabled = GetEnvironmentProperty(\"nightlight\")"
      ],
      "description": "This function is used for querying the current environment properties. The\navailable properties are exactly the same as in the editor.",
      "tables": {}
    },
    {
      "name": "SetPostProcessingDefault",
      "arguments": [],
      "returns": [],
      "examples": [
        "SetPostProcessingDefault()"
      ],
      "description": "Reset the post processing properties to default.",
      "tables": {}
    },
    {
      "name": "SetPostProcessingProperty",
      "arguments": [
        {
          "name": "name",
          "desc": "Property name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value0",
          "desc": "Property value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "value1",
          "desc": "Extra property value (only some properties)",
          "optional": true,
          "type": "number"
        },
        {
          "name": "value2",
          "desc": "Extra property value (only some properties)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Sepia post processing\nSetPostProcessingProperty(\"saturation\", 0.4)\nSetPostProcessingProperty(\"colorbalance\", 1.3, 1.0, 0.7)"
      ],
      "description": "This function is used for manipulating the post processing properties. The\navailable properties are exactly the same as in the editor.",
      "tables": {}
    },
    {
      "name": "GetPostProcessingProperty",
      "arguments": [
        {
          "name": "name",
          "desc": "Property name",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "value0",
          "desc": "Property value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "value1",
          "desc": "Property value (only some properties)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "value2",
          "desc": "Property value (only some properties)",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local saturation = GetPostProcessingProperty(\"saturation\")\nlocal r,g,b = GetPostProcessingProperty(\"colorbalance\")"
      ],
      "description": "This function is used for querying the current post processing properties. The\navailable properties are exactly the same as in the editor.",
      "tables": {}
    },
    {
      "name": "DrawLine",
      "arguments": [
        {
          "name": "p0",
          "desc": "World space point as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "p1",
          "desc": "World space point as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "r",
          "desc": "Red",
          "optional": true,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green",
          "optional": true,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue",
          "optional": true,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Draw white debug line\nDrawLine(Vec(0, 0, 0), Vec(-10, 5, -10))\n\n--Draw red debug line\nDrawLine(Vec(0, 0, 0), Vec(10, 5, 10), 1, 0, 0)"
      ],
      "description": "Draw a 3D line. In contrast to DebugLine, it will not show behind objects.\nDefault color is white.",
      "tables": {}
    },
    {
      "name": "DebugLine",
      "arguments": [
        {
          "name": "p0",
          "desc": "World space point as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "p1",
          "desc": "World space point as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "r",
          "desc": "Red",
          "optional": true,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green",
          "optional": true,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue",
          "optional": true,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Draw white debug line\nDebugLine(Vec(0, 0, 0), Vec(-10, 5, -10))\n\n--Draw red debug line\nDebugLine(Vec(0, 0, 0), Vec(10, 5, 10), 1, 0, 0)"
      ],
      "description": "Draw a 3D debug overlay line in the world. Default color is white.",
      "tables": {}
    },
    {
      "name": "DebugCross",
      "arguments": [
        {
          "name": "p0",
          "desc": "World space point as vector",
          "optional": false,
          "type": "table"
        },
        {
          "name": "r",
          "desc": "Red",
          "optional": true,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green",
          "optional": true,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue",
          "optional": true,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "DebugCross(Vec(10, 5, 5))"
      ],
      "description": "Draw a debug cross in the world to highlight a location. Default color is white.",
      "tables": {}
    },
    {
      "name": "DebugWatch",
      "arguments": [
        {
          "name": "name",
          "desc": "Name",
          "optional": false,
          "type": "string"
        },
        {
          "name": "value",
          "desc": "Value",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "local t = 5\nDebugWatch(\"time\", t)"
      ],
      "description": "Show a named valued on screen for debug purposes. Up to 32 values can be shown\nsimultaneously. Values updated the current frame are drawn opaque. Old values\nare drawn transparent in white. The function will also recognize vectors,\nquaternions and transforms as second argument and convert them to strings\nautomatically.",
      "tables": {}
    },
    {
      "name": "DebugPrint",
      "arguments": [
        {
          "name": "message",
          "desc": "Message to display",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "DebugPrint(\"time\")"
      ],
      "description": "Display message on screen. The last 20 lines are displayed.",
      "tables": {}
    },
    {
      "name": "UiMakeInteractive",
      "arguments": [],
      "returns": [],
      "examples": [
        "UiMakeInteractive()"
      ],
      "description": "Calling this function will disable game input, bring up the mouse pointer and\nallow Ui interaction with the calling script without pausing the game. This can\nbe useful to make interactive user interfaces from scripts while the game is\nrunning. Call this continuously every frame as long as Ui interaction is\ndesired.",
      "tables": {}
    },
    {
      "name": "UiPush",
      "arguments": [],
      "returns": [],
      "examples": [
        "UiColor(1,0,0)\nUiText(\"Red\")\nUiPush()\n\tUiColor(0,1,0)\n\tUiText(\"Green\")\nUiPop()\nUiText(\"Red\")"
      ],
      "description": "Push state onto stack. This is used in combination with UiPop to remember a\nstate and restore to that state later.",
      "tables": {}
    },
    {
      "name": "UiPop",
      "arguments": [],
      "returns": [],
      "examples": [
        "UiColor(1,0,0)\nUiText(\"Red\")\nUiPush()\n\tUiColor(0,1,0)\n\tUiText(\"Green\")\nUiPop()\nUiText(\"Red\")"
      ],
      "description": "Pop state from stack and make it the current one. This is used in combination\nwith UiPush to remember a previous state and go back to it later.",
      "tables": {}
    },
    {
      "name": "UiWidth",
      "arguments": [],
      "returns": [
        {
          "name": "width",
          "desc": "Width of draw context",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local w = UiWidth()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiHeight",
      "arguments": [],
      "returns": [
        {
          "name": "height",
          "desc": "Height of draw context",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local h = UiHeight()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiCenter",
      "arguments": [],
      "returns": [
        {
          "name": "center",
          "desc": "Half width of draw context",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local c = UiCenter()\n--Same as \nlocal c = UiWidth()/2"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiMiddle",
      "arguments": [],
      "returns": [
        {
          "name": "middle",
          "desc": "Half height of draw context",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local m = UiMiddle()\n--Same as\nlocal m = UiHeight()/2"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiColor",
      "arguments": [
        {
          "name": "r",
          "desc": "Red channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha channel. Default 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Set color yellow\nUiColor(1,1,0)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiColorFilter",
      "arguments": [
        {
          "name": "r",
          "desc": "Red channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha channel. Default 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiPush()\n\t--Draw menu in transparent, yellow color tint\n\tUiColorFilter(1, 1, 0, 0.5)\n\tdrawMenu()\nUiPop()"
      ],
      "description": "Color filter, multiplied to all future colors in this scope",
      "tables": {}
    },
    {
      "name": "UiTranslate",
      "arguments": [
        {
          "name": "x",
          "desc": "X component",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y component",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiPush()\n\tUiTranslate(100, 0)\n\tUiText(\"Indented\")\nUiPop()"
      ],
      "description": "Translate cursor",
      "tables": {}
    },
    {
      "name": "UiRotate",
      "arguments": [
        {
          "name": "angle",
          "desc": "Angle in degrees, counter clockwise",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiPush()\n\tUiRotate(45)\n\tUiText(\"Rotated\")\nUiPop()"
      ],
      "description": "Rotate cursor",
      "tables": {}
    },
    {
      "name": "UiScale",
      "arguments": [
        {
          "name": "x",
          "desc": "X component",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y component. Default value is x.",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiPush()\n\tUiScale(2)\n\tUiText(\"Double size\")\nUiPop()"
      ],
      "description": "Scale cursor either uniformly (one argument) or non-uniformly (two arguments)",
      "tables": {}
    },
    {
      "name": "UiWindow",
      "arguments": [
        {
          "name": "width",
          "desc": "Window width",
          "optional": false,
          "type": "number"
        },
        {
          "name": "height",
          "desc": "Window height",
          "optional": false,
          "type": "number"
        },
        {
          "name": "clip",
          "desc": "Clip content outside window. Default is false.",
          "optional": true,
          "type": "boolean"
        },
        {
          "name": "inherit",
          "desc": "Inherit current clip region (for nested clip regions)",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "UiPush()\n\tUiWindow(400, 200)\n\tlocal w = UiWidth()\n\t--w is now 400\nUiPop()"
      ],
      "description": "Set up new bounds. Calls to UiWidth, UiHeight, UiCenter and UiMiddle will\noperate in the context of the window size. If clip is set to true, contents of\nwindow will be clipped to bounds (only works properly for non-rotated windows).",
      "tables": {}
    },
    {
      "name": "UiSafeMargins",
      "arguments": [],
      "returns": [
        {
          "name": "x0",
          "desc": "Left",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y0",
          "desc": "Top",
          "optional": false,
          "type": "number"
        },
        {
          "name": "x1",
          "desc": "Right",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y1",
          "desc": "Bottom",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "function draw()\n\tlocal x0, y0, x1, y1 = UiSafeMargins()\n\tUiTranslate(x0, y0)\n\tUiWindow(x1-x0, y1-y0, true)\n\t--The drawing area is now 1920 by 1080 in the center of screen\n\tdrawMenu()\nend"
      ],
      "description": "Return a safe drawing area that will always be visible regardless of display\naspect ratio. The safe drawing area will always be 1920 by 1080 in size. This is\nuseful for setting up a fixed size UI.",
      "tables": {}
    },
    {
      "name": "UiAlign",
      "arguments": [
        {
          "name": "alignment",
          "desc": "Alignment keywords",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [],
      "examples": [
        "UiAlign(\"left\")\nUiText(\"Aligned left at baseline\")\n\nUiAlign(\"center middle\")\nUiText(\"Fully centered\")"
      ],
      "description": "The alignment determines how content is aligned with respect to the cursor.\n${table:Alignment} Alignment can contain combinations of these, for instance:\n\"center middle\", \"left top\", \"center top\", etc. If horizontal or vertical\nalginment is omitted it will depend on the element drawn. Text, for instance has\ndefault vertical alignment at baseline.",
      "tables": {
        "Alignment": [
          [
            "left",
            "Horizontally align to the left"
          ],
          [
            "right",
            "Horizontally align to the right"
          ],
          [
            "center",
            "Horizontally align to the center"
          ],
          [
            "top",
            "Vertically align to the top"
          ],
          [
            "bottom",
            "Veritcally align to the bottom"
          ],
          [
            "middle",
            "Vertically align to the middle"
          ]
        ]
      }
    },
    {
      "name": "UiModalBegin",
      "arguments": [],
      "returns": [],
      "examples": [
        "UiModalBegin()\nif UiTextButton(\"Okay\") then\n\t--All other interactive ui elements except this one are disabled\nend\nUiModalEnd()\n\n--This is also okay\nUiPush()\n\tUiModalBegin()\n\tif UiTextButton(\"Okay\") then\n\t\t--All other interactive ui elements except this one are disabled\n\tend\nUiPop()\n--No longer modal"
      ],
      "description": "Disable input for everything, except what's between UiModalBegin and UiModalEnd\n(or if modal state is popped)",
      "tables": {}
    },
    {
      "name": "UiModalEnd",
      "arguments": [],
      "returns": [],
      "examples": [
        "UiModalBegin()\nif UiTextButton(\"Okay\") then\n\t--All other interactive ui elements except this one are disabled\nend\nUiModalEnd()"
      ],
      "description": "Disable input for everything, except what's between UiModalBegin and UiModalEnd\nCalling this function is optional. Modality is part of the current state and\nwill be lost if modal state is popped.",
      "tables": {}
    },
    {
      "name": "UiDisableInput",
      "arguments": [],
      "returns": [],
      "examples": [
        "UiPush()\n\tUiDisableInput()\n\tif UiTextButton(\"Okay\") then\n\t\t--Will never happen\n\tend\nUiPop()"
      ],
      "description": "Disable input",
      "tables": {}
    },
    {
      "name": "UiEnableInput",
      "arguments": [],
      "returns": [],
      "examples": [
        "UiDisableInput()\nif UiTextButton(\"Okay\") then\n\t--Will never happen\nend\n\nUiEnableInput()\nif UiTextButton(\"Okay\") then\n\t--This can happen\nend"
      ],
      "description": "Enable input that has been previously disabled",
      "tables": {}
    },
    {
      "name": "UiReceivesInput",
      "arguments": [],
      "returns": [
        {
          "name": "receives",
          "desc": "True if current context receives input",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if UiReceivesInput() then\n\thighlightItemAtMousePointer()\nend"
      ],
      "description": "This function will check current state receives input. This is the case if input\nis not explicitly disabled with (with UiDisableInput) and no other state is\ncurrently modal (with UiModalBegin). Input functions and UI elements already do\nthis check internally, but it can sometimes be useful to read the input state\nmanually to trigger things in the UI.",
      "tables": {}
    },
    {
      "name": "UiGetMousePos",
      "arguments": [],
      "returns": [
        {
          "name": "x",
          "desc": "X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y coordinate",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local x, y = UiGetMousePos()"
      ],
      "description": "Get mouse pointer position relative to the cursor",
      "tables": {}
    },
    {
      "name": "UiIsMouseInRect",
      "arguments": [
        {
          "name": "w",
          "desc": "Width",
          "optional": false,
          "type": "number"
        },
        {
          "name": "h",
          "desc": "Height",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "inside",
          "desc": "True if mouse pointer is within rectangle",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if UiIsMouseInRect(100, 100) then\n\t-- mouse pointer is in rectangle\nend"
      ],
      "description": "Check if mouse pointer is within rectangle. Note that this function respects\nalignment.",
      "tables": {}
    },
    {
      "name": "UiWorldToPixel",
      "arguments": [
        {
          "name": "point",
          "desc": "3D world position as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "returns": [
        {
          "name": "x",
          "desc": "X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "distance",
          "desc": "Distance to point",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local x, y, dist = UiWorldToPixel(point)\nif dist > 0 then\nUiTranslate(x, y)\nUiText(\"Label\")\nend"
      ],
      "description": "Convert world space position to user interface X and Y coordinate relative to\nthe cursor. The distance is in meters and positive if in front of camera,\nnegative otherwise.",
      "tables": {}
    },
    {
      "name": "UiPixelToWorld",
      "arguments": [
        {
          "name": "x",
          "desc": "X coordinate",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "Y coordinate",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "direction",
          "desc": "3D world direction as vector",
          "optional": false,
          "type": "table"
        }
      ],
      "examples": [
        "UiMakeInteractive()\nlocal x, y = UiGetMousePos()\nlocal dir = UiPixelToWorld(x, y)\nlocal pos = GetCameraTransform().pos\nlocal hit, dist = QueryRaycast(pos, dir, 100)\nif hit then\n\tDebugPrint(\"hit distance: \" .. dist)\nend"
      ],
      "description": "Convert X and Y UI coordinate to a world direction, as seen from current camera.\nThis can be used to raycast into the scene from the mouse pointer position.",
      "tables": {}
    },
    {
      "name": "UiBlur",
      "arguments": [
        {
          "name": "amount",
          "desc": "Blur amount (0.0 to 1.0)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiBlur(1.0)\ndrawMenu()"
      ],
      "description": "Perform a gaussian blur on current screen content",
      "tables": {}
    },
    {
      "name": "UiFont",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to TTF font file",
          "optional": false,
          "type": "string"
        },
        {
          "name": "size",
          "desc": "Font size (10 to 100)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiFont(\"bold.ttf\", 24)\nUiText(\"Hello\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiFontHeight",
      "arguments": [],
      "returns": [
        {
          "name": "size",
          "desc": "Font size",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local h = UiFontHeight()"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiText",
      "arguments": [
        {
          "name": "text",
          "desc": "Print text at cursor location",
          "optional": false,
          "type": "string"
        },
        {
          "name": "move",
          "desc": "Automatically move cursor vertically. Default false.",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [
        {
          "name": "w",
          "desc": "Width of text",
          "optional": false,
          "type": "number"
        },
        {
          "name": "h",
          "desc": "Height of text",
          "optional": false,
          "type": "number"
        },
        {
          "name": "x",
          "desc": "End x-position of text. Only valid when \"advance cursor\" is false",
          "optional": false,
          "type": "number"
        },
        {
          "name": "y",
          "desc": "End y-position of text. Only valid when \"advance cursor\" is false",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "UiFont(\"bold.ttf\", 24)\nUiText(\"Hello\")\n\n...\n\n--Automatically advance cursor\nUiText(\"First line\", true)\nUiText(\"Second line\", true)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiGetTextSize",
      "arguments": [
        {
          "name": "text",
          "desc": "A text string",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "w",
          "desc": "Width of text",
          "optional": false,
          "type": "number"
        },
        {
          "name": "h",
          "desc": "Height of text",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local w, h = UiGetTextSize(\"Some text\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiWordWrap",
      "arguments": [
        {
          "name": "width",
          "desc": "Maximum width of text",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiWordWrap(200)\nUiText(\"Some really long text that will get wrapped into several lines\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiTextOutline",
      "arguments": [
        {
          "name": "r",
          "desc": "Red channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "thickness",
          "desc": "Outline thickness. Default is 0.1",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Black outline, standard thickness\nUiTextOutline(0,0,0,1)\nUiText(\"Text with outline\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiTextShadow",
      "arguments": [
        {
          "name": "r",
          "desc": "Red channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha channel",
          "optional": false,
          "type": "number"
        },
        {
          "name": "distance",
          "desc": "Shadow distance. Default is 1.0",
          "optional": true,
          "type": "number"
        },
        {
          "name": "blur",
          "desc": "Shadow blur. Default is 0.5",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Black drop shadow, 50% transparent, distance 2\nUiTextShadow(0, 0, 0, 0.5, 2.0)\nUiText(\"Text with drop shadow\")"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiRect",
      "arguments": [
        {
          "name": "w",
          "desc": "Width",
          "optional": false,
          "type": "number"
        },
        {
          "name": "h",
          "desc": "Height",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "--Draw full-screen black rectangle\nUiColor(0, 0, 0)\nUiRect(UiWidth(), UiHeight())\n\n--Draw smaller, red, rotating rectangle in center of screen\nUiPush()\n\tUiColor(1, 0, 0)\n\tUiTranslate(UiCenter(), UiMiddle())\n\tUiRotate(GetTime())\n\tUiAlign(\"center middle\")\n\tUiRect(100, 100)\nUiPop()"
      ],
      "description": "Draw solid rectangle at cursor position",
      "tables": {}
    },
    {
      "name": "UiImage",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to image (PNG or JPG format)",
          "optional": false,
          "type": "string"
        },
        {
          "name": "x0",
          "desc": "Lower x coordinate (default is 0)",
          "optional": true,
          "type": "number"
        },
        {
          "name": "y0",
          "desc": "Lower y coordinate (default is 0)",
          "optional": true,
          "type": "number"
        },
        {
          "name": "x1",
          "desc": "Upper x coordinate (default is image width)",
          "optional": true,
          "type": "number"
        },
        {
          "name": "y1",
          "desc": "Upper y coordinate (default is image height)",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "w",
          "desc": "Width of drawn image",
          "optional": false,
          "type": "number"
        },
        {
          "name": "h",
          "desc": "Height of drawn image",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Draw image in center of screen\nUiPush()\n\tUiTranslate(UiCenter(), UiMiddle())\n\tUiAlign(\"center middle\")\n\tUiImage(\"test.png\")\nUiPop()"
      ],
      "description": "Draw image at cursor position. If x0, y0, x1, y1 is provided a cropped version\nwill be drawn in that coordinate range.",
      "tables": {}
    },
    {
      "name": "UiGetImageSize",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to image (PNG or JPG format)",
          "optional": false,
          "type": "string"
        }
      ],
      "returns": [
        {
          "name": "w",
          "desc": "Image width",
          "optional": false,
          "type": "number"
        },
        {
          "name": "h",
          "desc": "Image height",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "local w,h = UiGetImageSize(\"test.png\")"
      ],
      "description": "Get image size",
      "tables": {}
    },
    {
      "name": "UiImageBox",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to image (PNG or JPG format)",
          "optional": false,
          "type": "string"
        },
        {
          "name": "width",
          "desc": "Width",
          "optional": false,
          "type": "number"
        },
        {
          "name": "height",
          "desc": "Height",
          "optional": false,
          "type": "number"
        },
        {
          "name": "borderWidth",
          "desc": "Border width",
          "optional": false,
          "type": "number"
        },
        {
          "name": "borderHeight",
          "desc": "Border height",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiImageBox(\"menu-frame.png\", 200, 200, 10, 10)"
      ],
      "description": "Draw 9-slice image at cursor position. Width should be at least 2*borderWidth.\nHeight should be at least 2*borderHeight.",
      "tables": {}
    },
    {
      "name": "UiSound",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to sound file (OGG format)",
          "optional": false,
          "type": "string"
        },
        {
          "name": "volume",
          "desc": "Playback volume. Default 1.0",
          "optional": true,
          "type": "number"
        },
        {
          "name": "pitch",
          "desc": "Playback pitch. Default 1.0",
          "optional": true,
          "type": "number"
        },
        {
          "name": "pan",
          "desc": "Playback stereo panning (-1.0 to 1.0). Default 0.0.",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiSound(\"click.ogg\")"
      ],
      "description": "UI sounds are not affected by acoustics simulation. Use LoadSound / PlaySound\nfor that.",
      "tables": {}
    },
    {
      "name": "UiSoundLoop",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to looping sound file (OGG format)",
          "optional": false,
          "type": "string"
        },
        {
          "name": "volume",
          "desc": "Playback volume. Default 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "if animating then\n\tUiSoundLoop(\"screech.ogg\")\nend"
      ],
      "description": "Call this continuously to keep playing loop. UI sounds are not affected by\nacoustics simulation. Use LoadLoop / PlayLoop for that.",
      "tables": {}
    },
    {
      "name": "UiMute",
      "arguments": [
        {
          "name": "amount",
          "desc": "Mute by this amount (0.0 to 1.0)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "music",
          "desc": "Mute music as well",
          "optional": true,
          "type": "boolean"
        }
      ],
      "returns": [],
      "examples": [
        "if menuOpen then\n\tUiMute(1.0)\nend"
      ],
      "description": "Mute game audio and optionally music for the next frame. Call continuously to\nstay muted.",
      "tables": {}
    },
    {
      "name": "UiButtonImageBox",
      "arguments": [
        {
          "name": "path",
          "desc": "Path to image (PNG or JPG format)",
          "optional": false,
          "type": "string"
        },
        {
          "name": "borderWidth",
          "desc": "Border width",
          "optional": false,
          "type": "number"
        },
        {
          "name": "borderHeight",
          "desc": "Border height",
          "optional": false,
          "type": "number"
        },
        {
          "name": "r",
          "desc": "Red multiply. Default 1.0",
          "optional": true,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green multiply. Default 1.0",
          "optional": true,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue multiply. Default 1.0",
          "optional": true,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha channel. Default 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiButtonImageBox(\"button-9slice.png\", 10, 10)\nif UiTextButton(\"Test\") then\n\t...\nend"
      ],
      "description": "Set up 9-slice image to be used as background for buttons.",
      "tables": {}
    },
    {
      "name": "UiButtonHoverColor",
      "arguments": [
        {
          "name": "r",
          "desc": "Red multiply",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green multiply",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue multiply",
          "optional": false,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha channel. Default 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiButtonHoverColor(1, 0, 0)\nif UiTextButton(\"Test\") then\n\t...\nend"
      ],
      "description": "Button color filter when hovering mouse pointer.",
      "tables": {}
    },
    {
      "name": "UiButtonPressColor",
      "arguments": [
        {
          "name": "r",
          "desc": "Red multiply",
          "optional": false,
          "type": "number"
        },
        {
          "name": "g",
          "desc": "Green multiply",
          "optional": false,
          "type": "number"
        },
        {
          "name": "b",
          "desc": "Blue multiply",
          "optional": false,
          "type": "number"
        },
        {
          "name": "a",
          "desc": "Alpha channel. Default 1.0",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiButtonPressColor(0, 1, 0)\nif UiTextButton(\"Test\") then\n\t...\nend"
      ],
      "description": "Button color filter when pressing down.",
      "tables": {}
    },
    {
      "name": "UiButtonPressDist",
      "arguments": [
        {
          "name": "dist",
          "desc": "Press distance",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [],
      "examples": [
        "UiButtonPressDistance(4)\nif UiTextButton(\"Test\") then\n\t...\nend"
      ],
      "description": "The button offset when being pressed",
      "tables": {}
    },
    {
      "name": "UiTextButton",
      "arguments": [
        {
          "name": "text",
          "desc": "Text on button",
          "optional": false,
          "type": "string"
        },
        {
          "name": "w",
          "desc": "Button width",
          "optional": true,
          "type": "number"
        },
        {
          "name": "h",
          "desc": "Button height",
          "optional": true,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "pressed",
          "desc": "True if user clicked button",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if UiTextButton(\"Test\") then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiImageButton",
      "arguments": [
        {
          "name": "path",
          "desc": "Image path (PNG or JPG file)",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "pressed",
          "desc": "True if user clicked button",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if UiImageButton(\"image.png\") then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiBlankButton",
      "arguments": [
        {
          "name": "w",
          "desc": "Button width",
          "optional": false,
          "type": "number"
        },
        {
          "name": "h",
          "desc": "Button height",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "pressed",
          "desc": "True if user clicked button",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "if UiBlankButton(30, 30) then\n\t...\nend"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiSlider",
      "arguments": [
        {
          "name": "path",
          "desc": "Image path (PNG or JPG file)",
          "optional": false,
          "type": "number"
        },
        {
          "name": "axis",
          "desc": "Drag axis, must be \"x\" or \"y\"",
          "optional": false,
          "type": "string"
        },
        {
          "name": "current",
          "desc": "Current value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "min",
          "desc": "Minimum value",
          "optional": false,
          "type": "number"
        },
        {
          "name": "max",
          "desc": "Maximum value",
          "optional": false,
          "type": "number"
        }
      ],
      "returns": [
        {
          "name": "value",
          "desc": "New value, same as current if not changed",
          "optional": false,
          "type": "number"
        },
        {
          "name": "done",
          "desc": "True if user is finished changing (released slider)",
          "optional": false,
          "type": "boolean"
        }
      ],
      "examples": [
        "value = UiSlider(\"dot.png\", \"x\", value, 0, 100)"
      ],
      "description": "",
      "tables": {}
    },
    {
      "name": "UiGetScreen",
      "arguments": [],
      "returns": [
        {
          "name": "handle",
          "desc": "Handle to the screen running this script or zero if none.",
          "optional": false,
          "type": "number"
        }
      ],
      "examples": [
        "--Turn off screen running current script\nscreen = UiGetScreen()\nSetScreenEnabled(screen, false)"
      ],
      "description": "",
      "tables": {}
    }
  ]
}